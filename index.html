<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gesture Christmas Tree (Mobile Optimized)</title>
    <style>
        :root {
            --color-bg: #050505;
            --color-text: #ffffff;
            --color-accent: #C41E3A;
            --color-gold: #FFD700;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* ç¦æ­¢æ‰‹æœºä¸‹æ‹‰åˆ·æ–°/æ»šåŠ¨ */
            -webkit-user-select: none;
            user-select: none;
        }

        /* 3D åœºæ™¯å®¹å™¨ */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* åŸå§‹è§†é¢‘æµ (ä¸å¯è§ï¼Œä½†ä¸èƒ½ display:noneï¼Œå¦åˆ™ MediaPipe æ— æ³•è¯»å–) */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; /* éšè— */
            z-index: -1;
            /* å…³é”®ï¼šé˜²æ­¢æ‰‹æœºç«¯è§†é¢‘è¢«æ‹‰ä¼¸ */
            width: 1px;
            height: 1px;
            object-fit: cover;
        }

        /* UI å±‚ */
        .ui-layer {
            position: absolute;
            z-index: 20;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }

        /* çŠ¶æ€æŒ‡ç¤º */
        #status-panel {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            white-space: nowrap;
        }

        #status-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--color-gold);
        }

        /* æ‰‹åŠ¿æŒ‡å— (æ‰‹æœºç«¯ç®€åŒ–æ˜¾ç¤º) */
        #gesture-guide {
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 8px;
            max-width: 200px;
        }

        .guide-row { margin-bottom: 4px; }

        /* å¯åŠ¨é®ç½© (å¿…é¡»ç”¨äºç§»åŠ¨ç«¯è§¦å‘æƒé™) */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: var(--color-accent);
            color: #fff;
            border: none;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(196, 30, 58, 0.5);
            cursor: pointer;
            margin-top: 20px;
        }
        
        #loading-text {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
            display: none;
        }

        /* è°ƒè¯•çª—å£ (ç”¨äºç¡®è®¤æ‰‹åŠ¿è¯†åˆ«æƒ…å†µ) */
        #debug-canvas {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px; /* æ‰‹æœºä¸Šæ”¹å°ä¸€ç‚¹ */
            height: auto; /* ä¿æŒæ¯”ä¾‹ */
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            z-index: 10;
            background: #000;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤ºï¼Œç¬¦åˆè‡ªæ‹ä¹ æƒ¯ */
        }
    </style>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Start Screen -->
    <div id="start-overlay">
        <h1 style="color:var(--color-gold); text-align:center; padding:0 20px;">ğŸ„ Gesture Tree</h1>
        <p style="color:#ccc; text-align:center; padding:0 30px; font-size:14px;">
            è¯·å…è®¸æ‘„åƒå¤´æƒé™<br>ä¿æŒæ‰‹éƒ¨åœ¨å±å¹•å¯è§èŒƒå›´å†…
        </p>
        <button id="start-btn">ç‚¹å‡»å¼€å¯ä½“éªŒ</button>
        <div id="loading-text">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</div>
    </div>

    <!-- UI -->
    <div id="status-panel" class="ui-layer">
        <div id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
    </div>

    <div id="gesture-guide" class="ui-layer">
        <div class="guide-row">âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘</div>
        <div class="guide-row">ğŸ– å¼ å¼€ï¼šæ•£å¼€æ˜Ÿå°˜</div>
        <div class="guide-row">ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç…§ç‰‡</div>
        <div class="guide-row">ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’</div>
    </div>

    <!-- Elements -->
    <video id="input-video" playsinline webkit-playsinline></video>
    <canvas id="debug-canvas"></canvas>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Config ---
        const CONFIG = {
            particleCount: 1200, // ç§»åŠ¨ç«¯ç¨å¾®å‡å°‘ç²’å­æ•°ä»¥ä¿æµç•…
            photoCount: 30,
            colors: { green: 0x2F5A46, gold: 0xFFD700, red: 0xC41E3A, white: 0xFFFFFF },
            lerpSpeed: 0.08
        };

        const STATE = {
            target: 'tree',
            rotationX: 0,
            handPresent: false
        };

        // --- Three.js Application ---
        class ChristmasApp {
            constructor() {
                this.container = document.getElementById('canvas-container');
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.03);

                this.camera = new THREE.PerspectiveCamera(65, this.width / this.height, 0.1, 1000);
                this.camera.position.set(0, 10, 45); // ç¨å¾®æ‹‰è¿œä¸€ç‚¹é€‚åº”æ‰‹æœºçª„å±

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(this.width, this.height);
                // å…³é”®ï¼šé«˜åˆ†å±é™åˆ¶åƒç´ æ¯”ï¼Œé˜²æ­¢å°ç±³15è¿‡çƒ­
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                // Post Processing
                this.composer = new EffectComposer(this.renderer);
                this.renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(this.renderPass);
                
                // è¾‰å…‰å‚æ•°è°ƒæ•´
                this.bloomPass = new UnrealBloomPass(new THREE.Vector2(this.width, this.height), 1.5, 0.4, 0.85);
                this.bloomPass.strength = 1.0;
                this.bloomPass.radius = 0.5;
                this.bloomPass.threshold = 0.2;
                this.composer.addPass(this.bloomPass);

                this.treeGroup = new THREE.Group();
                this.scene.add(this.treeGroup);

                this.initAssets();
                
                window.addEventListener('resize', this.onResize.bind(this));
                
                this.clock = new THREE.Clock();
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);
            }

            initAssets() {
                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.2);
                this.scene.add(ambient);
                const pLight = new THREE.PointLight(CONFIG.colors.gold, 2, 50);
                pLight.position.set(0, 20, 10);
                this.scene.add(pLight);

                // Textures (Procedural)
                const pTexture = this.createGradientTexture();

                // Particles
                const geo = new THREE.BufferGeometry();
                const pos = [], cols = [], sizes = [];
                const targetTree = [], targetScatter = [];

                const colorArr = [
                    new THREE.Color(CONFIG.colors.green), new THREE.Color(CONFIG.colors.green),
                    new THREE.Color(CONFIG.colors.gold), new THREE.Color(CONFIG.colors.red),
                    new THREE.Color(CONFIG.colors.white)
                ];

                const height = 30;
                const radius = 12;

                for(let i=0; i<CONFIG.particleCount; i++) {
                    // Tree Shape
                    const rRatio = i/CONFIG.particleCount;
                    const y = rRatio * height - height/2;
                    const r = (1 - rRatio) * radius + Math.random();
                    const angle = i * 0.15;
                    const x = Math.cos(angle * 10) * r;
                    const z = Math.sin(angle * 10) * r;
                    targetTree.push(x, y, z);

                    // Scatter Shape
                    const sr = 30 + Math.random()*20;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    targetScatter.push(
                        sr * Math.sin(phi) * Math.cos(theta),
                        sr * Math.sin(phi) * Math.sin(theta),
                        sr * Math.cos(phi)
                    );

                    pos.push(x, y, z);
                    const c = colorArr[Math.floor(Math.random() * colorArr.length)];
                    cols.push(c.r, c.g, c.b);
                    sizes.push(Math.random()*0.8 + 0.2);
                }

                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                geo.userData = { tree: targetTree, scatter: targetScatter };

                const mat = new THREE.PointsMaterial({
                    size: 0.8, vertexColors: true, map: pTexture,
                    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
                });
                this.particles = new THREE.Points(geo, mat);
                this.treeGroup.add(this.particles);

                // Photos placeholders
                this.photos = [];
                const planeGeo = new THREE.PlaneGeometry(3, 4);
                for(let i=0; i<CONFIG.photoCount; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64; canvas.height = 80;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,64,80);
                    ctx.fillStyle = i%2===0 ? '#C41E3A':'#2F5A46'; ctx.fillRect(2,2,60,60);
                    const tex = new THREE.CanvasTexture(canvas);
                    
                    const mesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({map: tex, side: THREE.DoubleSide}));
                    
                    // Spiral position
                    const h = (i/CONFIG.photoCount) * height - height/2;
                    const r = (1 - i/CONFIG.photoCount) * radius + 2;
                    const a = i * 0.8;
                    mesh.position.set(Math.cos(a)*r, h, Math.sin(a)*r);
                    mesh.lookAt(0, h, 0);
                    mesh.rotateY(Math.PI);
                    
                    mesh.userData = {
                        treePos: mesh.position.clone(),
                        treeRot: mesh.rotation.clone(),
                        scatterPos: new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60),
                        zoomPos: new THREE.Vector3((Math.random()-0.5)*8, (Math.random()-0.5)*10, 35 + Math.random()*5)
                    };
                    this.photos.push(mesh);
                    this.treeGroup.add(mesh);
                }
            }

            createGradientTexture() {
                const c = document.createElement('canvas');
                c.width=32; c.height=32;
                const ctx = c.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(c);
            }

            onResize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.camera.aspect = this.width / this.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.width, this.height);
                this.composer.setSize(this.width, this.height);
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                // State Logic
                const pos = this.particles.geometry.attributes.position.array;
                const targets = (STATE.target === 'tree') ? this.particles.geometry.userData.tree : this.particles.geometry.userData.scatter;

                // Particle update
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const i3 = i*3;
                    pos[i3] += (targets[i3] - pos[i3]) * CONFIG.lerpSpeed;
                    pos[i3+1] += (targets[i3+1] - pos[i3+1]) * CONFIG.lerpSpeed;
                    pos[i3+2] += (targets[i3+2] - pos[i3+2]) * CONFIG.lerpSpeed;
                    
                    if(STATE.target === 'tree') pos[i3+1] += Math.sin(Date.now()*0.002 + i)*0.03; // twinkle
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                // Photo update
                this.photos.forEach(p => {
                    let tPos = p.userData.treePos;
                    if(STATE.target === 'scatter') tPos = p.userData.scatterPos;
                    if(STATE.target === 'zoom') tPos = p.userData.zoomPos;
                    
                    p.position.lerp(tPos, CONFIG.lerpSpeed);
                    
                    if(STATE.target === 'zoom') {
                        p.lookAt(this.camera.position);
                    } else if (STATE.target === 'tree') {
                        // Approximate return to rotation
                        // For simplicity in this demo, we just look at center and flip
                        p.lookAt(0, p.position.y, 0); 
                        p.rotateY(Math.PI);
                    }
                });

                // Rotation Control
                // Smooth damping
                const targetRot = STATE.rotationX; 
                this.treeGroup.rotation.y += (targetRot - this.treeGroup.rotation.y) * 0.1;
                
                // Auto rotate if idle
                if(!STATE.handPresent) this.treeGroup.rotation.y += 0.003;

                this.composer.render();
            }
        }

        // --- MediaPipe Logic ---
        
        const videoElement = document.getElementById('input-video');
        const debugCanvas = document.getElementById('debug-canvas');
        const ctx = debugCanvas.getContext('2d');
        const statusEl = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('start-overlay');
        const loadText = document.getElementById('loading-text');

        let app; 
        let hands;
        let camera;

        // è·ç¦»è®¡ç®—è¾…åŠ©
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x-p2.x, 2) + Math.pow(p1.y-p2.y, 2));

        function onResults(results) {
            // ç¡®ä¿ debug canvas å°ºå¯¸åŒ¹é…å›¾åƒï¼Œé¿å…æ‹‰ä¼¸
            if(debugCanvas.width !== results.image.width || debugCanvas.height !== results.image.height){
                debugCanvas.width = results.image.width;
                debugCanvas.height = results.image.height;
            }

            ctx.save();
            ctx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            ctx.drawImage(results.image, 0, 0, debugCanvas.width, debugCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handPresent = true;
                const lm = results.multiHandLandmarks[0];
                drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(ctx, lm, {color: '#FF0000', lineWidth: 1});

                // 1. æ—‹è½¬æ§åˆ¶ (æ˜ å°„ X è½´)
                // ç§»åŠ¨ç«¯è‡ªæ‹é•œåƒæ˜¯åçš„ï¼Œéœ€è¦è°ƒæ•´é€»è¾‘
                // lm[9] æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ¯”è¾ƒç¨³å®š
                let handX = lm[9].x; 
                STATE.rotationX = (handX - 0.5) * 5; // è°ƒæ•´ç³»æ•°å¢åŠ çµæ•åº¦

                // 2. æ‰‹åŠ¿è¯†åˆ«
                const wrist = lm[0];
                const tips = [8, 12, 16, 20]; // é£ŸæŒ‡åˆ°å°æŒ‡å°–
                const pips = [6, 10, 14, 18]; // å¯¹åº”å…³èŠ‚

                // è®¡ç®—ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡
                let openFingers = 0;
                tips.forEach((tipIdx, i) => {
                    if (dist(lm[tipIdx], wrist) > dist(lm[pips[i]], wrist)) openFingers++;
                });

                // æåˆæ£€æµ‹ (æ‹‡æŒ‡4 å’Œ é£ŸæŒ‡8)
                const pinchDist = dist(lm[4], lm[8]);
                
                // çŠ¶æ€æœº
                if (pinchDist < 0.04) { // æåˆé˜ˆå€¼ï¼Œæ ¹æ®ç»éªŒè°ƒæ•´
                    if(STATE.target !== 'zoom') {
                        STATE.target = 'zoom';
                        statusEl.innerText = "ğŸ” ç…§ç‰‡é¢„è§ˆæ¨¡å¼";
                        statusEl.style.color = "#fff";
                    }
                } else if (openFingers >= 4) {
                    if(STATE.target !== 'scatter') {
                        STATE.target = 'scatter';
                        statusEl.innerText = "âœ¨ æ˜Ÿå°˜æ•£å¼€";
                        statusEl.style.color = CONFIG.colors.red;
                    }
                } else if (openFingers <= 1) { // æ¡æ‹³
                    if(STATE.target !== 'tree') {
                        STATE.target = 'tree';
                        statusEl.innerText = "ğŸ„ åœ£è¯æ ‘æ¨¡å¼";
                        statusEl.style.color = CONFIG.colors.gold;
                    }
                }

            } else {
                STATE.handPresent = false;
                statusEl.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                statusEl.style.color = "#ccc";
            }
            ctx.restore();
        }

        async function init() {
            startBtn.style.display = 'none';
            loadText.style.display = 'block';

            // 1. Init Three.js
            app = new ChristmasApp();

            // 2. Init MediaPipe
            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // ç§»åŠ¨ç«¯ç”¨1å¹³è¡¡æ€§èƒ½å’Œç²¾åº¦
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);

            // 3. Setup Camera (Mobile Optimized)
            const isMobile = window.innerWidth < 768;
            
            // é’ˆå¯¹å°ç±³15ç­‰ç«–å±è®¾å¤‡çš„ç‰¹æ®Šé…ç½®
            // ä¸æŒ‡å®šå…·ä½“çš„å®½é«˜åƒç´ ï¼Œè€Œæ˜¯æ ¹æ®æ¯”ä¾‹ï¼Œæˆ–è€…è®© CameraUtils è‡ªåŠ¨å¤„ç†
            // å…³é”®æ˜¯ä¸è¦åœ¨ CSS é‡ŒæŠŠ video å‹æ‰
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                // åœ¨ç§»åŠ¨ç«¯è¯·æ±‚ç«–å±åˆ†è¾¨ç‡ï¼ŒPCç«¯è¯·æ±‚æ¨ªå±
                width: isMobile ? 480 : 1280,
                height: isMobile ? 640 : 720,
                facingMode: 'user'
            });

            try {
                await camera.start();
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 500);
            } catch (e) {
                console.error(e);
                loadText.innerText = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥HTTPSå’Œæƒé™è®¾ç½®";
                alert("æ— æ³•å¯åŠ¨æ‘„åƒå¤´ã€‚è¯·ç¡®ä¿æ‚¨ä½¿ç”¨çš„æ˜¯HTTPSåè®®ï¼Œå¹¶å…è®¸äº†æ‘„åƒå¤´æƒé™ã€‚");
            }
        }

        startBtn.addEventListener('click', init);

    </script>
</body>
</html>