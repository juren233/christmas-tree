<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree: Silky Smooth</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; font-family: -apple-system, sans-serif; }
        
        /* 3D åœºæ™¯ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* éšè—è§†é¢‘æº */
        #input-video { position: absolute; top: 0; left: 0; width: 10px; height: 10px; opacity: 0; pointer-events: none; z-index: -10; }

        /* çŠ¶æ€ UI */
        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(10,10,10,0.7); backdrop-filter: blur(10px);
            padding: 8px 24px; border-radius: 30px; border: 1px solid rgba(255,215,0,0.3);
            display: flex; align-items: center; gap: 10px; z-index: 10;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); pointer-events: none;
        }
        .dot { width: 8px; height: 8px; background: #555; border-radius: 50%; transition: background 0.3s; }
        .dot.active { background: #0f0; box-shadow: 0 0 8px #0f0; }
        #status-text { color: #FFD700; font-size: 14px; font-weight: 600; }

        /* å¯åŠ¨å±‚ */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #btn-start {
            background: linear-gradient(135deg, #2F5A46, #1a3328); border: 1px solid #FFD700;
            color: #FFD700; padding: 18px 48px; font-size: 18px; border-radius: 50px; 
            margin-top: 20px; box-shadow: 0 0 30px rgba(47, 90, 70, 0.6);
        }
        
        /* è°ƒè¯•å°çª— (ç¡®è®¤æ˜¯å¦è¯†åˆ«åˆ°) */
        #debug-preview {
            position: absolute; bottom: 20px; right: 20px; width: 80px; height: 106px;
            background: #111; border: 2px solid #333; border-radius: 8px; z-index: 5;
            opacity: 0.8; pointer-events: none; transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <div id="status-bar">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">ç­‰å¾…å¯åŠ¨...</span>
    </div>

    <div id="overlay">
        <h1 style="color:#C41E3A; font-weight:800; letter-spacing:2px;">ğŸ„ æè‡´å¹³æ»‘ç‰ˆ</h1>
        <p style="color:#888; font-size:12px">é˜²æŠ–ç®—æ³• + 120Hz æ’å€¼æ¸²æŸ“</p>
        <button id="btn-start" onclick="init()">ç‚¹å‡»å¼€å§‹</button>
        <div id="msg" style="color:#666; font-size:12px; margin-top:15px"></div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="debug-preview"></canvas>
    <div id="canvas-container"></div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€æ§åˆ¶å˜é‡ ---
        // è¿™é‡Œå­˜å‚¨çš„æ˜¯â€œç›®æ ‡å€¼â€ï¼ŒAIåªè´Ÿè´£æ›´æ–°è¿™é‡Œ
        const TARGETS = {
            rotSpeed: 0.002, // ç›®æ ‡æ—‹è½¬é€Ÿåº¦
            state: 'tree',   // ç›®æ ‡çŠ¶æ€
            handConf: 0      // æ‰‹åŠ¿ç½®ä¿¡åº¦ (ç§¯åˆ†å™¨)
        };

        // è¿™é‡Œå­˜å‚¨çš„æ˜¯â€œå½“å‰æ˜¾ç¤ºå€¼â€ï¼Œæ¸²æŸ“å¾ªç¯è´Ÿè´£å¹³æ»‘é€¼è¿‘ç›®æ ‡å€¼
        const CURRENT = {
            rot: 0,
            rotSpeed: 0.002,
            lerpFactor: 0.05 // å¹³æ»‘ç³»æ•°ï¼Œè¶Šå°è¶Šé¡ºæ»‘
        };

        const video = document.getElementById('input-video');
        const previewCanvas = document.getElementById('debug-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const msg = document.getElementById('msg');
        
        // ç”¨äº AI ç¼©æ”¾å¤„ç†çš„ Canvas
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });

        // --- 1. é«˜å“è´¨ 3D æ¸²æŸ“ (æ¸²æŸ“ä¸AIè§£è€¦) ---
        class SmoothScene {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.02);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 10, 42);

                this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // è¾‰å…‰ (Bloom)
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                this.initObjects();
                this.animate();
                window.addEventListener('resize', () => this.resize());
            }

            initObjects() {
                // ç¯å…‰
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.1));
                const l = new THREE.PointLight(0xFFD700, 2, 60);
                l.position.set(0, 20, 10);
                this.scene.add(l);

                // 1. ç²’å­
                const pGeo = new THREE.BufferGeometry();
                const pos=[], col=[], tTree=[], tScatter=[];
                const colors = [0x2F5A46, 0xFFD700, 0xC41E3A, 0xFFFFFF].map(c=>new THREE.Color(c));

                for(let i=0; i<1500; i++) {
                    const rRatio = i/1500;
                    // Tree shape
                    const y = rRatio * 35 - 17.5;
                    const r = (1-rRatio) * 12 + Math.random();
                    const a = i * 0.2;
                    tTree.push(Math.cos(a*9)*r, y, Math.sin(a*9)*r);
                    
                    // Scatter shape
                    const sr = 35 + Math.random()*20;
                    const phi = Math.random()*Math.PI*2, theta = Math.random()*Math.PI;
                    tScatter.push(sr*Math.sin(theta)*Math.cos(phi), sr*Math.sin(theta)*Math.sin(phi), sr*Math.cos(theta));

                    pos.push(tTree[i*3], tTree[i*3+1], tTree[i*3+2]);
                    const c = colors[i%4];
                    col.push(c.r, c.g, c.b);
                }
                pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                pGeo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
                pGeo.userData = { tree: tTree, scatter: tScatter };

                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                
                const pMat = new THREE.PointsMaterial({
                    size: 0.7, vertexColors: true, map: new THREE.CanvasTexture(cvs),
                    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
                });
                this.particles = new THREE.Points(pGeo, pMat);
                this.group.add(this.particles);

                // 2. ç…§ç‰‡
                this.photos = [];
                const plane = new THREE.PlaneGeometry(3.5, 4.5);
                for(let i=0; i<20; i++){
                    const m = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color:i%2?0xC41E3A:0x2F5A46, side:2}));
                    const y = (i/20)*30-15, r = (1-i/20)*12+3, a = i*0.8;
                    m.userData = {
                        tree: new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r),
                        zoom: new THREE.Vector3((Math.random()-.5)*10, (Math.random()-.5)*10, 35+Math.random()*5),
                        scatter: new THREE.Vector3((Math.random()-.5)*60, (Math.random()-.5)*60, (Math.random()-.5)*60)
                    };
                    m.position.copy(m.userData.tree);
                    m.lookAt(0,y,0); m.rotateY(Math.PI);
                    this.photos.push(m);
                    this.group.add(m);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // --- æ ¸å¿ƒå¹³æ»‘é€»è¾‘ (Anti-Twitch) ---
                
                // 1. æ—‹è½¬é€Ÿåº¦å¹³æ»‘æ’å€¼
                // æ— è®º AI æ€ä¹ˆè·³ï¼ŒrotSpeed éƒ½æ˜¯æ…¢æ…¢å˜åŒ–çš„
                CURRENT.rotSpeed += (TARGETS.rotSpeed - CURRENT.rotSpeed) * 0.05;
                this.group.rotation.y += CURRENT.rotSpeed;

                // 2. ç²’å­ä¸ç…§ç‰‡ä½ç½®å¹³æ»‘æ’å€¼
                const pos = this.particles.geometry.attributes.position.array;
                const tgtName = TARGETS.state; // è·å–å½“å‰ç¨³å®šçš„ç›®æ ‡çŠ¶æ€
                const tgtArr = tgtName==='tree' ? this.particles.geometry.userData.tree : this.particles.geometry.userData.scatter;

                // ç²’å­æ’å€¼
                for(let i=0; i<pos.length; i++) {
                    // ä½¿ç”¨ 0.08 çš„ç³»æ•°ï¼Œä¿è¯é¡ºæ»‘ç§»åŠ¨ï¼Œç»ä¸ç¬ç§»
                    pos[i] += (tgtArr[i] - pos[i]) * 0.08;
                }
                // å¾®å¼±é—ªçƒ
                if(tgtName==='tree') {
                    for(let i=1; i<pos.length; i+=3) pos[i] += Math.sin(Date.now()*0.002 + i)*0.01;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                // ç…§ç‰‡æ’å€¼
                this.photos.forEach(p => {
                    let t = p.userData.tree;
                    if(tgtName==='scatter') t = p.userData.scatter;
                    if(tgtName==='zoom') t = p.userData.zoom;
                    
                    p.position.lerp(t, 0.08);

                    if(tgtName==='zoom') {
                        p.lookAt(this.camera.position);
                    } else {
                        // å¹³æ»‘æ¢å¤æœå‘
                        const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.atan2(p.position.x, p.position.z)+Math.PI, 0));
                        p.quaternion.slerp(q, 0.1);
                    }
                });

                this.composer.render();
            }

            resize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- 2. AI å¤„ç† (é˜²æŠ–åŠ¨) ---
        window.init = async function() {
            const btn = document.getElementById('btn-start');
            btn.style.display = 'none';
            msg.innerText = "å¯åŠ¨è§†è§‰å¼•æ“...";

            // å¯åŠ¨ 3D
            new SmoothScene();

            try {
                // å¯åŠ¨æ‘„åƒå¤´
                msg.innerText = "è¿æ¥æ‘„åƒå¤´...";
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();

                // å¯åŠ¨ MediaPipe
                msg.innerText = "åŠ è½½ AI æ¨¡å‹...";
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // ä½¿ç”¨æ ‡å‡†æ¨¡å‹ï¼Œå‡å°‘é¬¼æ‰‹
                    minDetectionConfidence: 0.6,
                    minTrackingConfidence: 0.6
                });
                hands.onResults(onResults);
                
                await hands.initialize();
                
                // éšè—é®ç½©
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = 0;
                setTimeout(()=>overlay.style.display='none', 500);

                // å¯åŠ¨å¾ªç¯
                startLoop(hands);

            } catch(e) {
                alert("å¯åŠ¨å¤±è´¥: " + e.message);
                btn.style.display = 'block';
            }
        };

        // æ™ºèƒ½å¾ªç¯ï¼šæ ¹æ®è®¾å¤‡æ€§èƒ½è‡ªåŠ¨è°ƒèŠ‚
        function startLoop(hands) {
            let lastTime = 0;
            const targetFPS = 30; // é”å®š AI å¸§ç‡ï¼Œä¸è®©å®ƒè·‘å¤ªå¿«å¯¼è‡´è¿‡çƒ­ï¼Œä¹Ÿä¸è®©å®ƒè·‘å¤ªæ…¢
            const interval = 1000 / targetFPS;

            const loop = async (now) => {
                if (video.paused || video.ended) return;

                if (now - lastTime >= interval) {
                    lastTime = now;

                    // 1. é™é‡‡æ ·åˆ° 360pï¼Œä¿è¯é€Ÿåº¦
                    const w = 360;
                    const h = video.videoHeight * (w / video.videoWidth);
                    if(processCanvas.width !== w) { processCanvas.width=w; processCanvas.height=h; }
                    
                    // 2. ç»˜åˆ¶
                    processCtx.drawImage(video, 0, 0, w, h);

                    // 3. è¯†åˆ«
                    try {
                        await hands.send({image: processCanvas});
                    } catch(e) {}
                }
                
                // ä½¿ç”¨ rVFC ç¡®ä¿è·Ÿè§†é¢‘æµåŒæ­¥
                if ('requestVideoFrameCallback' in video) {
                    video.requestVideoFrameCallback(() => loop(performance.now()));
                } else {
                    requestAnimationFrame(loop);
                }
            };
            requestAnimationFrame(loop);
        }

        // --- æ ¸å¿ƒï¼šç»“æœå¤„ç†ä¸é˜²æŠ– ---
        // ä¿¡å·ç§¯åˆ†å™¨ï¼šé˜²æ­¢çŠ¶æ€é—ªçƒ
        let handPresenceIntegrator = 0; 
        const PRESENCE_THRESHOLD = 3; // è¿ç»­ 3 å¸§è¯†åˆ«åˆ°æ‰ç®—æœ‰æ‰‹

        function onResults(results) {
            // ç»˜åˆ¶é¢„è§ˆ (è¯æ˜ AI æ´»ç€)
            previewCanvas.width = processCanvas.width;
            previewCanvas.height = processCanvas.height;
            previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks.length > 0) {
                // åªæœ‰è¿ç»­è¯†åˆ«åˆ°ï¼Œç§¯åˆ†æ‰å¢åŠ 
                handPresenceIntegrator = Math.min(handPresenceIntegrator + 1, 10);
            } else {
                // åªæœ‰è¿ç»­ä¸¢å¤±ï¼Œç§¯åˆ†æ‰å‡å°‘
                handPresenceIntegrator = Math.max(handPresenceIntegrator - 1, 0);
            }

            // çœŸæ­£çš„â€œæœ‰æ‰‹â€åˆ¤æ–­ï¼šåŸºäºç§¯åˆ†å™¨
            const isStableHand = handPresenceIntegrator >= PRESENCE_THRESHOLD;

            if (isStableHand && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // ç»˜åˆ¶éª¨æ¶
                drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: '#0f0', lineWidth: 2});
                statusDot.classList.add('active');

                // 1. è®¡ç®—æ—‹è½¬é€Ÿåº¦ç›®æ ‡å€¼
                // æ ¹æ®æ‰‹åœ¨å±å¹•çš„ä½ç½® X (0-1)
                // 0.5 æ˜¯ä¸­å¿ƒã€‚å·¦è¾¹æ˜¯æ­£è½¬ï¼Œå³è¾¹æ˜¯åè½¬
                // é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼Œé˜²æ­¢å¤ªå¿«
                const x = lm[9].x; 
                const speedRaw = (0.5 - x) * 0.1; 
                TARGETS.rotSpeed = speedRaw; // äº¤ç»™æ¸²æŸ“å¾ªç¯å»å¹³æ»‘æ’å€¼

                // 2. çŠ¶æ€åˆ¤å®š (ç®€å•é€»è¾‘ï¼Œé˜²è¯¯è§¦)
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                
                // æ‰‹æŒ‡å±•å¼€æ£€æµ‹
                const wrist = lm[0];
                let open = 0;
                [8,12,16,20].forEach((t, i) => {
                    const p = [6,10,14,18][i];
                    if(Math.hypot(lm[t].x-wrist.x, lm[t].y-wrist.y) > Math.hypot(lm[p].x-wrist.x, lm[p].y-wrist.y)) open++;
                });

                if (pinch < 0.08) {
                    TARGETS.state = 'zoom';
                    statusText.innerText = "ğŸ” ç…§ç‰‡é¢„è§ˆ";
                    statusText.style.color = "#fff";
                } else if (open >= 4) {
                    TARGETS.state = 'scatter';
                    statusText.innerText = "âœ¨ æ˜Ÿå°˜æ•£å¼€";
                    statusText.style.color = "#C41E3A";
                } else {
                    TARGETS.state = 'tree';
                    statusText.innerText = "ğŸ„ åœ£è¯æ ‘";
                    statusText.style.color = "#FFD700";
                }

            } else {
                // æ²¡æ‰‹çš„æ—¶å€™
                statusDot.classList.remove('active');
                statusText.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                statusText.style.color = "#aaa";
                
                // æ¢å¤é»˜è®¤è‡ªæ—‹
                TARGETS.rotSpeed = 0.003;
                // åªæœ‰å½“ç§¯åˆ†å™¨å®Œå…¨å½’é›¶ï¼Œæ‰é‡ç½®å›æ ‘ï¼Œé˜²æ­¢é—ªçƒ
                if (handPresenceIntegrator === 0) {
                    TARGETS.state = 'tree';
                }
            }
        }

    </script>
</body>
</html>