<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree: Android Fix</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #000;
            font-family: sans-serif; touch-action: none;
        }

        /* 3D å®¹å™¨ */
        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        /* å…³é”®ä¿®æ”¹ï¼šè§†é¢‘å…ƒç´ ä¸èƒ½å¤ªå°ï¼Œå¿…é¡»â€œå¯è§â€ä½†é€æ˜ï¼Œå¦åˆ™å°ç±³æµè§ˆå™¨ä¸æ¸²æŸ“ */
        #input-video {
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; /* è®©å®ƒæ’‘æ»¡ï¼Œä¿æŒæ¯”ä¾‹ */
            height: 100%; 
            object-fit: cover;
            opacity: 0.001; /* å‡ ä¹é€æ˜ï¼Œä½†ä¸æ˜¯ display:none */
            z-index: -5; 
            pointer-events: none;
        }

        /* è°ƒè¯•å°çª— */
        #debug-canvas {
            position: absolute; bottom: 10px; right: 10px;
            width: 120px; height: 160px; /* ç«–å±æ¯”ä¾‹ */
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 100;
            border-radius: 8px;
            /* é•œåƒç¿»è½¬ï¼Œç¬¦åˆè‡ªæ‹ç›´è§‰ */
            transform: scaleX(-1); 
        }

        /* æ•°æ®è°ƒè¯•é¢æ¿ */
        #data-debug {
            position: absolute; top: 10px; left: 10px;
            font-size: 12px; color: #0f0; background: rgba(0,0,0,0.6);
            padding: 8px; z-index: 200; pointer-events: none;
            border-radius: 4px; line-height: 1.5;
        }

        /* å¯åŠ¨é®ç½© */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        
        button {
            background: #2F5A46; color: #fff; border: 1px solid #FFD700;
            padding: 15px 50px; border-radius: 50px; font-size: 18px;
            margin-top: 20px; box-shadow: 0 0 20px rgba(47, 90, 70, 0.8);
        }

        /* çŠ¶æ€æç¤º */
        #ui-panel {
            position: absolute; top: 60px; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }
        #status-text {
            display: inline-block; padding: 5px 15px;
            background: rgba(0,0,0,0.5); border-radius: 15px;
            color: #FFD700; font-weight: bold; border: 1px solid #FFD700;
        }
    </style>
</head>
<body>

    <!-- è°ƒè¯•æ•°æ® -->
    <div id="data-debug">
        SYSTEM: Ready<br>
        RES: -<br>
        HAND: Searching...
    </div>

    <!-- å¯åŠ¨å±‚ -->
    <div id="overlay">
        <h1 style="color:#C41E3A; margin-bottom:10px;">ğŸ„ åœ£è¯æ ‘æ‰‹åŠ¿ç‰ˆ</h1>
        <p style="color:#ccc; font-size:12px;">é€‚é…å°ç±³15 / iOS</p>
        <button id="btn-start">å¼€å¯æ‘„åƒå¤´</button>
    </div>

    <div id="ui-panel"><div id="status-text">ç­‰å¾…å¯åŠ¨...</div></div>

    <!-- è§†é¢‘æµ -->
    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    
    <!-- è°ƒè¯•ç”»å¸ƒ -->
    <canvas id="debug-canvas"></canvas>
    
    <!-- 3D åœºæ™¯ -->
    <div id="canvas-container"></div>

    <!-- ä¾èµ–åº“ -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€å˜é‡ ---
        const video = document.getElementById('input-video');
        const dbgCanvas = document.getElementById('debug-canvas');
        const dbgCtx = dbgCanvas.getContext('2d');
        const debugEl = document.getElementById('data-debug');
        const statusEl = document.getElementById('status-text');
        
        // ä¸­é—´å±‚ Canvas (ç”¨äºæ¸…æ´—è§†é¢‘æ•°æ®)
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d');

        const STATE = { target: 'tree', rotX: 0, hasHand: false };
        let app = null;

        // --- 1. Three.js åœºæ™¯ ---
        class App {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.03);
                
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 10, 45);

                this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // è¾‰å…‰
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                this.bloom.strength = 1.0; this.bloom.radius = 0.5; this.bloom.threshold = 0.2;
                this.composer.addPass(this.bloom);

                this.initObjects();
                this.animate();
                window.addEventListener('resize', () => this.resize());
            }

            initObjects() {
                const group = new THREE.Group();
                this.scene.add(group);
                this.group = group;

                // ç¯å…‰
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.2));
                const l = new THREE.PointLight(0xFFD700, 2, 50);
                l.position.set(0, 20, 10);
                this.scene.add(l);

                // ç²’å­
                const geo = new THREE.BufferGeometry();
                const pos=[], col=[], sizes=[];
                const tTree=[], tScatter=[];
                const colors = [0x2F5A46, 0xFFD700, 0xC41E3A, 0xFFFFFF].map(c=>new THREE.Color(c));

                for(let i=0; i<1200; i++) {
                    const rRatio = i/1200;
                    // Tree
                    const y = rRatio * 30 - 15;
                    const r = (1-rRatio)*12 + Math.random();
                    const a = i * 0.2;
                    tTree.push(Math.cos(a*8)*r, y, Math.sin(a*8)*r);
                    
                    // Scatter
                    const sr = 35 + Math.random()*15;
                    const phi = Math.random()*Math.PI*2, theta = Math.random()*Math.PI;
                    tScatter.push(sr*Math.sin(theta)*Math.cos(phi), sr*Math.sin(theta)*Math.sin(phi), sr*Math.cos(theta));
                    
                    pos.push(tTree[i*3], tTree[i*3+1], tTree[i*3+2]);
                    const c = colors[i%4];
                    col.push(c.r, c.g, c.b);
                    sizes.push(Math.random()*0.8+0.4);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes,1));
                geo.userData = {tree:tTree, scatter:tScatter};

                const tex = this.makeTex();
                const mat = new THREE.PointsMaterial({size:0.8, vertexColors:true, map:tex, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true});
                this.parts = new THREE.Points(geo, mat);
                group.add(this.parts);

                // ç…§ç‰‡
                this.photos = [];
                const pGeo = new THREE.PlaneGeometry(3,4);
                for(let i=0; i<20; i++){
                    const m = new THREE.Mesh(pGeo, new THREE.MeshBasicMaterial({color:i%2?0xC41E3A:0x2F5A46, side:2}));
                    const y = (i/20)*30-15, r = (1-i/20)*12+2, a = i*0.5;
                    m.userData = {
                        tree: new THREE.Vector3(Math.cos(a*5)*r, y, Math.sin(a*5)*r),
                        zoom: new THREE.Vector3((Math.random()-.5)*6, (Math.random()-.5)*6, 32+Math.random()*4),
                        scatter: new THREE.Vector3((Math.random()-.5)*60, (Math.random()-.5)*60, (Math.random()-.5)*60)
                    };
                    m.position.copy(m.userData.tree);
                    m.lookAt(0,y,0); m.rotateY(Math.PI);
                    this.photos.push(m);
                    group.add(m);
                }
            }

            makeTex() {
                const c = document.createElement('canvas'); c.width=32; c.height=32;
                const ctx = c.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(c);
            }

            resize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(()=>this.animate());
                
                // ç²’å­è¿åŠ¨
                const pos = this.parts.geometry.attributes.position.array;
                const tgt = STATE.target === 'tree' ? this.parts.geometry.userData.tree : this.parts.geometry.userData.scatter;
                for(let i=0; i<1200; i++) {
                    const k=i*3;
                    pos[k] += (tgt[k]-pos[k])*0.08;
                    pos[k+1] += (tgt[k+1]-pos[k+1])*0.08;
                    pos[k+2] += (tgt[k+2]-pos[k+2])*0.08;
                }
                this.parts.geometry.attributes.position.needsUpdate = true;

                // ç…§ç‰‡è¿åŠ¨
                this.photos.forEach(p => {
                    let t = p.userData.tree;
                    if(STATE.target==='scatter') t = p.userData.scatter;
                    if(STATE.target==='zoom') t = p.userData.zoom;
                    p.position.lerp(t, 0.08);
                    
                    if(STATE.target==='zoom') p.lookAt(this.camera.position);
                    else {
                        const lookT = STATE.target==='scatter'? p.position : new THREE.Vector3(0,p.position.y,0);
                        p.lookAt(lookT); if(STATE.target==='tree') p.rotateY(Math.PI);
                    }
                });

                // æ—‹è½¬
                const targetRot = STATE.rotX;
                this.group.rotation.y += (targetRot - this.group.rotation.y)*0.1;
                if(!STATE.hasHand) this.group.rotation.y += 0.003;

                this.composer.render();
            }
        }

        // --- 2. AI é€»è¾‘ ---
        async function initAI() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // ç§»åŠ¨ç«¯ 1 æ›´ç²¾å‡†ï¼Œè‹¥å¡é¡¿æ”¹ 0
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                // ç»˜åˆ¶è°ƒè¯•
                dbgCanvas.width = processCanvas.width;
                dbgCanvas.height = processCanvas.height;
                dbgCtx.clearRect(0,0,dbgCanvas.width, dbgCanvas.height);
                // ç”»å‡º AI çœ‹åˆ°çš„å®é™…å›¾åƒ
                dbgCtx.drawImage(results.image, 0, 0, dbgCanvas.width, dbgCanvas.height);

                if (results.multiHandLandmarks.length > 0) {
                    STATE.hasHand = true;
                    const lm = results.multiHandLandmarks[0];
                    drawConnectors(dbgCtx, lm, HAND_CONNECTIONS, {color:'#0f0', lineWidth:2});
                    drawLandmarks(dbgCtx, lm, {color:'#f00', lineWidth:1});

                    // 1. æ—‹è½¬ (é•œåƒå¤„ç†)
                    STATE.rotX = (0.5 - lm[9].x) * 4;

                    // 2. æåˆè®¡ç®— (æ›´å®½æ¾çš„é˜ˆå€¼)
                    const dPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    
                    // 3. å±•å¼€è®¡ç®—
                    const wrist = lm[0];
                    let openFingers = 0;
                    [8,12,16,20].forEach((tip, i) => {
                        const pip = [6,10,14,18][i];
                        if(Math.hypot(lm[tip].x-wrist.x, lm[tip].y-wrist.y) > Math.hypot(lm[pip].x-wrist.x, lm[pip].y-wrist.y)) 
                            openFingers++;
                    });

                    // çŠ¶æ€åˆ¤å®š
                    let txt = "HAND DETECTED";
                    let col = "#fff";

                    // é˜ˆå€¼ï¼š0.08 é€‚é… iPhone SE
                    if (dPinch < 0.08) {
                        STATE.target = 'zoom';
                        txt = "ğŸ” æåˆ: ç…§ç‰‡é¢„è§ˆ";
                    } else if (openFingers >= 4) {
                        STATE.target = 'scatter';
                        txt = "âœ¨ å¼ å¼€: æ˜Ÿå°˜çˆ†å‘";
                        col = "#C41E3A";
                    } else if (openFingers <= 1) {
                        STATE.target = 'tree';
                        txt = "ğŸ„ æ¡æ‹³: åœ£è¯æ ‘";
                        col = "#FFD700";
                    }
                    
                    statusEl.innerText = txt;
                    statusEl.style.color = col;
                    debugEl.innerHTML = `RES: ${processCanvas.width}x${processCanvas.height}<br>PINCH: ${dPinch.toFixed(3)}<br>STATE: ${STATE.target}`;

                } else {
                    STATE.hasHand = false;
                    statusEl.innerText = "è¯·å°†æ‰‹æ”¾å…¥ç”»é¢";
                    statusEl.style.color = "#aaa";
                    debugEl.innerHTML = `RES: ${processCanvas.width}x${processCanvas.height}<br>HAND: NO`;
                }
            });
            return hands;
        }

        // --- 3. æ‘„åƒå¤´å¯åŠ¨ä¸å¾ªç¯ ---
        async function start() {
            document.getElementById('btn-start').innerText = "æ­£åœ¨å¯åŠ¨...";
            
            app = new App();
            const hands = await initAI();

            try {
                // è¯·æ±‚æ‘„åƒå¤´
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 }, // ä¸è¦å¼ºåˆ¶ï¼Œç»™ä¸ªç†æƒ³å€¼
                        height: { ideal: 480 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                
                // ç­‰å¾…å…ƒæ•°æ®
                video.onloadedmetadata = () => {
                    document.getElementById('overlay').style.opacity = 0;
                    setTimeout(()=>document.getElementById('overlay').style.display='none', 500);
                    video.play();
                    processLoop(hands);
                };

            } catch(e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e.message);
                console.error(e);
            }
        }

        // æ ¸å¿ƒå¾ªç¯ï¼šæ‰‹åŠ¨å°†è§†é¢‘ç”»åˆ° Canvas å†ä¼ ç»™ AI
        async function processLoop(hands) {
            if (video.readyState >= 2) {
                // 1. è®¾ç½®ä¸­é—´å±‚ Canvas å°ºå¯¸åŒ¹é…è§†é¢‘æµ
                if (processCanvas.width !== video.videoWidth) {
                    processCanvas.width = video.videoWidth;
                    processCanvas.height = video.videoHeight;
                }
                
                // 2. æ¸…æ´—æ•°æ®ï¼šå°† Video å¸§ç”»åˆ° Canvas ä¸Š
                // è¿™æ­¥æ“ä½œä¼šå¼ºåˆ¶æµè§ˆå™¨è§£ç å½“å‰å¸§ï¼Œè§£å†³â€œè§†é¢‘å…ƒç´ ä¸å¯è§å¯¼è‡´ä¸è§£ç â€çš„é—®é¢˜
                processCtx.drawImage(video, 0, 0);

                // 3. å‘é€æ¸…æ´—åçš„ Canvas ç»™ AI
                await hands.send({image: processCanvas});
            }
            requestAnimationFrame(() => processLoop(hands));
        }

        document.getElementById('btn-start').onclick = start;

    </script>
</body>
</html>