<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree: Final Rescue</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; font-family: monospace; }
        
        /* è§†é¢‘å±‚ï¼šä¿æŒä¸€å®šå¤§å°ç¡®ä¿æµè§ˆå™¨æ¸²æŸ“ï¼Œä½†é€æ˜ä¸å¯è§ */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; opacity: 0.01; z-index: -10; pointer-events: none;
        }

        /* 3D å±‚ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* è°ƒè¯•é¢æ¿ */
        #debug-panel {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            pointer-events: none; z-index: 20;
        }
        .log-line { color: #0f0; background: rgba(0,0,0,0.7); display: inline-block; padding: 2px 5px; margin-bottom: 2px; border-radius: 4px; font-size: 12px; }
        .error-line { color: #f00 !important; }

        /* å¯åŠ¨é®ç½© */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff;
        }
        #btn-start {
            padding: 15px 40px; font-size: 18px; background: #C41E3A; color: white; border: none; border-radius: 50px; margin-top: 20px;
        }
        
        /* å…³é”®ï¼šçŠ¶æ€æŒ‡ç¤ºå™¨ */
        #ai-status {
            margin-top: 10px; font-size: 14px; color: #FFD700;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>ğŸ„ åœ£è¯æ ‘ä¿®å¤ç‰ˆ</h1>
        <div id="ai-status">ç­‰å¾…ç”¨æˆ·æ“ä½œ...</div>
        <button id="btn-start" onclick="startApp()">ç‚¹å‡»å¼€å§‹</button>
        <p style="color:#666; font-size:12px; margin-top:20px;">å¦‚æœç‚¹å‡»åâ€œæ¨¡å‹çŠ¶æ€â€é•¿æ—¶é—´å¡åœ¨ Loading<br>è¯·æ£€æŸ¥ç½‘ç»œæˆ–å¼€å¯ Wi-Fi</p>
    </div>

    <div id="debug-panel">
        <div class="log-line" id="log-sys">Sys: Init</div><br>
        <div class="log-line" id="log-model">Model: Idle</div><br>
        <div class="log-line" id="log-hand">Hand: No</div><br>
        <div class="log-line" id="log-fps">FPS: 0</div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <!-- ä¾èµ– -->
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <!-- é”å®šç‰ˆæœ¬ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€å˜é‡ ---
        const logs = {
            sys: document.getElementById('log-sys'),
            model: document.getElementById('log-model'),
            hand: document.getElementById('log-hand'),
            fps: document.getElementById('log-fps')
        };
        const statusEl = document.getElementById('ai-status');
        const video = document.getElementById('input-video');
        
        // é™é‡‡æ · Canvas (å…³é”®ä¼˜åŒ–ï¼šåªå¤„ç† 320px å®½åº¦çš„å›¾åƒ)
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d', { alpha: false }); // ä¼˜åŒ–æ€§èƒ½
        
        const STATE = { target: 'tree', rotX: 0, lastTime: 0 };
        
        // --- 1. Three.js æç®€è®¾ç½® ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 40);
        const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // é™ä½DPI
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.5, 0.4));

        // ç®€å•ç²’å­
        const group = new THREE.Group(); scene.add(group);
        const pMat = new THREE.PointsMaterial({size:0.8, color:0xFFD700, blending:THREE.AdditiveBlending, transparent:true});
        const pGeo = new THREE.BufferGeometry();
        const pos = [], basePos = [];
        for(let i=0; i<800; i++){
            const y = (i/800)*30 - 15;
            const r = (1-i/800)*10 + Math.random();
            const a = i * 0.3;
            const x = Math.cos(a)*r, z = Math.sin(a)*r;
            pos.push(x,y,z); basePos.push(x,y,z);
        }
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const particles = new THREE.Points(pGeo, pMat);
        group.add(particles);
        scene.add(new THREE.AmbientLight(0xffffff,0.5));

        function render3D() {
            requestAnimationFrame(render3D);
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<800; i++){
                const idx = i*3;
                let tx = basePos[idx], ty = basePos[idx+1], tz = basePos[idx+2];
                if(STATE.target === 'scatter') {
                    tx *= 3; ty *= 3; tz *= 3;
                } else if(STATE.target === 'zoom') {
                    tz += 20;
                }
                positions[idx] += (tx - positions[idx]) * 0.1;
                positions[idx+1] += (ty - positions[idx+1]) * 0.1;
                positions[idx+2] += (tz - positions[idx+2]) * 0.1;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            group.rotation.y += (STATE.rotX - group.rotation.y) * 0.1;
            if(STATE.target === 'tree') group.rotation.y += 0.005;
            composer.render();
        }
        render3D();
        window.onresize = () => { renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); };

        // --- 2. æ ¸å¿ƒï¼šå¸¦é”™è¯¯å¤„ç†çš„ AI å¯åŠ¨ ---
        window.startApp = async function() {
            document.getElementById('btn-start').style.display = 'none';
            statusEl.innerText = "æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´...";
            
            try {
                // 1. å¯åŠ¨æ‘„åƒå¤´
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();
                logs.sys.innerText = `Cam: ${video.videoWidth}x${video.videoHeight}`;

                // 2. åŠ è½½æ¨¡å‹
                statusEl.innerText = "æ­£åœ¨ä¸‹è½½ AI æ¨¡å‹ (çº¦5MB)...";
                logs.model.innerText = "Model: Loading...";
                
                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // å…³é”®ï¼šä½¿ç”¨ 0 å·æ¨¡å‹ (Lite)ï¼Œé€Ÿåº¦æœ€å¿«ï¼Œå…¼å®¹æ€§æœ€å¥½
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);
                
                // 3. é¢„çƒ­æ¨¡å‹ (å¼ºåˆ¶åˆå§‹åŒ–)
                statusEl.innerText = "æ­£åœ¨åˆå§‹åŒ–å¼•æ“...";
                await hands.initialize();
                
                statusEl.innerText = "å¯åŠ¨æˆåŠŸï¼";
                logs.model.innerText = "Model: Active";
                setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);

                // 4. å¼€å§‹å¾ªç¯
                processLoop(hands);

            } catch (err) {
                console.error(err);
                statusEl.innerText = "é”™è¯¯: " + err.message;
                statusEl.style.color = "red";
                logs.sys.innerText = "Error: " + err.message;
                logs.sys.classList.add('error-line');
                alert("å¯åŠ¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç½‘ç»œæ— æ³•ä¸‹è½½æ¨¡å‹ï¼Œæˆ–æ‘„åƒå¤´è¢«æ‹’ç»ã€‚\n" + err.message);
            }
        }

        // --- 3. ç»“æœå¤„ç† ---
        function onResults(results) {
            STATE.lastTime = performance.now();
            
            if (results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                logs.hand.innerText = "Hand: Yes";
                logs.hand.style.color = "#0f0";
                
                // ç®€å•é€»è¾‘
                STATE.rotX = (0.5 - lm[9].x) * 4;
                
                // æåˆ
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                // å¼ å¼€
                const wrist = lm[0];
                let open = 0;
                [8,12,16,20].forEach((t,i) => {
                    const p = [6,10,14,18][i];
                    if(Math.hypot(lm[t].x-wrist.x, lm[t].y-wrist.y) > Math.hypot(lm[p].x-wrist.x, lm[p].y-wrist.y)) open++;
                });

                if(pinch < 0.08) STATE.target = 'zoom';
                else if(open >= 4) STATE.target = 'scatter';
                else STATE.target = 'tree';

            } else {
                logs.hand.innerText = "Hand: Searching...";
                logs.hand.style.color = "yellow";
            }
        }

        // --- 4. ä¼˜åŒ–å¾ªç¯ (é™é‡‡æ ·) ---
        let lastFrameTime = 0;
        const FPS_LIMIT = 30; // é™åˆ¶ AI å¸§ç‡ï¼Œé˜²æ­¢è¿‡çƒ­

        async function processLoop(hands) {
            const now = performance.now();
            if (now - lastFrameTime >= 1000 / FPS_LIMIT) {
                lastFrameTime = now;
                logs.fps.innerText = `Time: ${(now % 1000).toFixed(0)}`;

                if (video.readyState >= 2) {
                    // å¼ºåˆ¶ç¼©æ”¾åˆ° 320px å®½ï¼Œä¿æŒæ¯”ä¾‹
                    const scale = 320 / video.videoWidth;
                    const w = 320;
                    const h = video.videoHeight * scale;
                    
                    if(processCanvas.width !== w) {
                        processCanvas.width = w;
                        processCanvas.height = h;
                    }

                    // ç»˜åˆ¶è¿™ä¸€å¸§
                    processCtx.drawImage(video, 0, 0, w, h);
                    
                    // å‘é€ç»™ AI
                    try {
                        await hands.send({image: processCanvas});
                    } catch(e) {
                        logs.model.innerText = "Err: Send Fail";
                    }
                }
            }
            requestAnimationFrame(() => processLoop(hands));
        }

        // å…¨å±€é”™è¯¯æ•è·
        window.onerror = function(msg, url, line) {
            alert("JS Error: " + msg);
            return false;
        };

    </script>
</body>
</html>