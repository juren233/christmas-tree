<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magical Christmas Tree</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; font-family: -apple-system, sans-serif; }
        
        /* ä¸»åœºæ™¯ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* éšè—çš„æºè§†é¢‘ (é€»è¾‘æ ¸å¿ƒ) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; opacity: 0; pointer-events: none; z-index: -1;
        }

        /* çŠ¶æ€ UI */
        #ui-layer {
            position: absolute; top: 20px; width: 100%; text-align: center; z-index: 10;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .status-badge {
            display: inline-flex; align-items: center; gap: 8px;
            background: rgba(20, 20, 20, 0.6); backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            padding: 8px 20px; border-radius: 30px;
            color: #FFD700; font-weight: 600; font-size: 14px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .indicator { width: 8px; height: 8px; background: #555; border-radius: 50%; transition: 0.3s; }
        .indicator.active { background: #0f0; box-shadow: 0 0 10px #0f0; }

        /* å³ä¸‹è§’é¢„è§ˆ (å¸¦éª¨æ¶ç»˜åˆ¶) */
        #preview-canvas {
            position: absolute; bottom: 20px; right: 20px; width: 100px; height: 133px;
            background: rgba(0,0,0,0.8); border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px; z-index: 20; transform: scaleX(-1);
        }

        /* å¯åŠ¨é®ç½© */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #btn-start {
            background: #C41E3A; color: white; border: none; padding: 16px 48px;
            font-size: 18px; border-radius: 50px; cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 30px rgba(196, 30, 58, 0.5);
        }
        #loading-text { color: #888; font-size: 12px; margin-top: 15px; }
    </style>
</head>
<body>

    <!-- UI -->
    <div id="ui-layer">
        <div class="status-badge">
            <div class="indicator" id="status-dot"></div>
            <span id="status-text">ç­‰å¾…å¯åŠ¨...</span>
        </div>
    </div>

    <!-- å¯åŠ¨å± -->
    <div id="overlay">
        <h1 style="color:#FFD700">ğŸ„ åœ£è¯æ ‘æ‰‹åŠ¿ç‰ˆ</h1>
        <p style="color:#ccc; font-size:12px">é€‚é… Xiaomi 15 120Hz é«˜åˆ·å±</p>
        <button id="btn-start" onclick="initApp()">å¼€å¯ä½“éªŒ</button>
        <div id="loading-text"></div>
    </div>

    <!-- æ ¸å¿ƒç»„ä»¶ -->
    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="preview-canvas"></canvas>
    <div id="canvas-container"></div>

    <!-- ä¾èµ– -->
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€å˜é‡ ---
        const STATE = { target: 'tree', rot: 0, hasHand: false };
        const video = document.getElementById('input-video');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const loadText = document.getElementById('loading-text');

        // AI å¤„ç†ç”¨çš„ç¦»å± Canvas
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d', { willReadFrequently: true });

        // --- 1. è¿˜åŸç²¾ç¾ 3D åœºæ™¯ ---
        class ChristmasScene {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.025);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 8, 40);

                this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPI
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // è¾‰å…‰
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight), 1.5, 0.4, 0.85));

                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                this.initContent();
                this.animate();
                window.addEventListener('resize', () => this.resize());
            }

            initContent() {
                // ç¯å…‰
                const amb = new THREE.AmbientLight(0xffffff, 0.1);
                const point = new THREE.PointLight(0xFFD700, 2, 80);
                point.position.set(0, 20, 10);
                this.scene.add(amb, point);

                // 1. ç²’å­ (Spiral Tree)
                const pGeo = new THREE.BufferGeometry();
                const count = 1500;
                const pos=[], col=[], tTree=[], tScatter=[];
                const colors = [0x2F5A46, 0xFFD700, 0xC41E3A, 0xFFFFFF].map(c=>new THREE.Color(c));

                for(let i=0; i<count; i++) {
                    const rRatio = i/count;
                    // Tree Shape
                    const y = rRatio * 35 - 17.5;
                    const r = (1-rRatio) * 12 + Math.random();
                    const a = i * 0.2;
                    tTree.push(Math.cos(a*8)*r, y, Math.sin(a*8)*r);
                    
                    // Scatter Shape
                    const sr = 40 + Math.random()*20;
                    const theta = Math.random()*Math.PI*2, phi = Math.random()*Math.PI;
                    tScatter.push(sr*Math.sin(phi)*Math.cos(theta), sr*Math.sin(phi)*Math.sin(theta), sr*Math.cos(phi));

                    pos.push(tTree[i*3], tTree[i*3+1], tTree[i*3+2]);
                    const c = colors[i%4];
                    col.push(c.r, c.g, c.b);
                }
                pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                pGeo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
                pGeo.userData = { tree: tTree, scatter: tScatter };

                // çº¹ç†
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                
                const pMat = new THREE.PointsMaterial({
                    size: 0.6, vertexColors: true, map: new THREE.CanvasTexture(cvs),
                    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
                });
                this.particles = new THREE.Points(pGeo, pMat);
                this.group.add(this.particles);

                // 2. ç…§ç‰‡ (Placeholders)
                this.photos = [];
                const plane = new THREE.PlaneGeometry(3,4);
                for(let i=0; i<25; i++) {
                    const m = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color: i%2?0xC41E3A:0x2F5A46, side:2}));
                    const y = (i/25)*30 - 15;
                    const r = (1-i/25)*12 + 2.5;
                    const a = i * 0.8;
                    m.userData = {
                        tree: new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r),
                        zoom: new THREE.Vector3((Math.random()-.5)*8, (Math.random()-.5)*8, 35+Math.random()*2),
                        scatter: new THREE.Vector3((Math.random()-.5)*80, (Math.random()-.5)*80, (Math.random()-.5)*80)
                    };
                    m.position.copy(m.userData.tree);
                    m.lookAt(0,y,0); m.rotateY(Math.PI);
                    this.photos.push(m);
                    this.group.add(m);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 1. æ—‹è½¬å¹³æ»‘
                this.group.rotation.y += (STATE.rot - this.group.rotation.y) * 0.05;
                if(!STATE.hasHand) this.group.rotation.y += 0.003; // è‡ªæ—‹

                // 2. çŠ¶æ€æ’å€¼
                const pos = this.particles.geometry.attributes.position.array;
                const tgt = STATE.target==='tree' ? this.particles.geometry.userData.tree : this.particles.geometry.userData.scatter;
                
                for(let i=0; i<pos.length; i++) {
                    pos[i] += (tgt[i] - pos[i]) * 0.08;
                }
                if(STATE.target==='tree') { // é—ªçƒæ•ˆæœ
                    for(let i=1; i<pos.length; i+=3) pos[i] += Math.sin(Date.now()*0.003+i)*0.02;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                this.photos.forEach(p => {
                    let t = p.userData.tree;
                    if(STATE.target==='scatter') t = p.userData.scatter;
                    if(STATE.target==='zoom') t = p.userData.zoom;
                    p.position.lerp(t, 0.08);
                    
                    if(STATE.target==='zoom') p.lookAt(this.camera.position);
                    else {
                        const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.atan2(p.position.x, p.position.z)+Math.PI, 0));
                        p.quaternion.slerp(q, 0.1);
                    }
                });

                this.composer.render();
            }
            
            resize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // --- 2. AI å¤„ç†ç³»ç»Ÿ (é’ˆå¯¹é«˜åˆ·å±ä¼˜åŒ–) ---
        window.initApp = async function() {
            const btn = document.getElementById('btn-start');
            btn.style.display = 'none';
            loadText.innerText = "æ­£åœ¨åˆå§‹åŒ–å›¾å½¢å¼•æ“...";
            
            // å¯åŠ¨ 3D
            const scene3d = new ChristmasScene();

            try {
                // A. å¯åŠ¨æ‘„åƒå¤´
                loadText.innerText = "è¯·æ±‚æ‘„åƒå¤´æƒé™...";
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();

                // B. åŠ è½½ MediaPipe
                loadText.innerText = "åŠ è½½ AI æ¨¡å‹...";
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // ä½¿ç”¨æ ‡å‡†æ¨¡å‹ï¼Œä¸è¦ç”¨ Lite
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);
                
                loadText.innerText = "é¢„çƒ­ AI å¼•æ“...";
                await hands.initialize();

                // C. éšè—å¯åŠ¨é¡µ
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 500);

                // D. å¯åŠ¨å¸§åŒæ­¥å¾ªç¯ (å…³é”®ä¿®æ”¹)
                startFrameLoop(hands);

            } catch (err) {
                console.error(err);
                alert("å¯åŠ¨å¤±è´¥: " + err.message);
                btn.style.display = 'block';
                btn.innerText = "é‡è¯•";
            }
        }

        // æ ¸å¿ƒï¼šä½¿ç”¨ requestVideoFrameCallback æ›¿ä»£ rAF
        function startFrameLoop(hands) {
            const processFrame = async (now, metadata) => {
                if (video.paused || video.ended) return;

                // 1. è®¾ç½®å¤„ç†å°ºå¯¸ (ä¿æŒ320å®½ï¼Œæ—¢æ¸…æ™°åˆå¿«)
                const w = 320;
                const h = video.videoHeight * (320 / video.videoWidth);
                if (processCanvas.width !== w) {
                    processCanvas.width = w;
                    processCanvas.height = h;
                }

                // 2. ç»˜åˆ¶å½“å‰è§†é¢‘å¸§
                processCtx.drawImage(video, 0, 0, w, h);

                // 3. å‘é€ç»™ AI (å¿…é¡» awaitï¼Œé˜²æ­¢ç§¯å‹)
                try {
                    await hands.send({image: processCanvas});
                } catch(e) {
                    console.error("AI Drop", e);
                }

                // 4. è¯·æ±‚ä¸‹ä¸€å¸§ (ç¡¬ä»¶åŒæ­¥)
                if ('requestVideoFrameCallback' in video) {
                    video.requestVideoFrameCallback(processFrame);
                } else {
                    // é™çº§å…¼å®¹æ—§æµè§ˆå™¨
                    requestAnimationFrame(() => processFrame());
                }
            };

            // å¯åŠ¨ç¬¬ä¸€å¸§
            if ('requestVideoFrameCallback' in video) {
                video.requestVideoFrameCallback(processFrame);
            } else {
                requestAnimationFrame(() => processFrame());
            }
        }

        function onResults(results) {
            // ç»˜åˆ¶é¢„è§ˆ (å³ä¸‹è§’)
            previewCanvas.width = processCanvas.width;
            previewCanvas.height = processCanvas.height;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks.length > 0) {
                STATE.hasHand = true;
                const lm = results.multiHandLandmarks[0];
                
                // ç”»éª¨æ¶ (ç»¿è‰²è¯æ˜è¯†åˆ«æˆåŠŸ)
                drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                
                statusDot.classList.add('active');
                
                // --- é€»è¾‘åˆ¤æ–­ ---
                // 1. æ—‹è½¬ (é•œåƒä¿®æ­£)
                STATE.rot = (0.5 - lm[9].x) * 5;

                // 2. æåˆ
                const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                // 3. å±•å¼€
                const wrist = lm[0];
                let open = 0;
                [8,12,16,20].forEach((tip, i) => {
                    const pip = [6,10,14,18][i];
                    if (Math.hypot(lm[tip].x-wrist.x, lm[tip].y-wrist.y) > Math.hypot(lm[pip].x-wrist.x, lm[pip].y-wrist.y)) open++;
                });

                if (pinch < 0.08) {
                    STATE.target = 'zoom';
                    statusText.innerText = "ğŸ” ç…§ç‰‡é¢„è§ˆ";
                    statusText.style.color = "#fff";
                } else if (open >= 4) {
                    STATE.target = 'scatter';
                    statusText.innerText = "âœ¨ æ˜Ÿå°˜æ•£å¼€";
                    statusText.style.color = "#C41E3A";
                } else {
                    STATE.target = 'tree';
                    statusText.innerText = "ğŸ„ åœ£è¯æ ‘";
                    statusText.style.color = "#FFD700";
                }
            } else {
                STATE.hasHand = false;
                statusDot.classList.remove('active');
                statusText.innerText = "è¯·å±•ç¤ºæ‰‹åŠ¿...";
                statusText.style.color = "#aaa";
            }
        }

    </script>
</body>
</html>