<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minimalist CPU Fix</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        
        /* 调试信息区 - 显眼 */
        #status-box {
            position: absolute; top: 0; left: 0; width: 100%; 
            background: rgba(20,0,0,0.9); color: #fff; 
            padding: 10px; z-index: 1000; font-family: monospace; font-size: 14px;
            pointer-events: none; border-bottom: 2px solid red;
        }
        .ok { color: #0f0; } .err { color: #f00; }

        /* 3D 区域 */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* 必须存在的视频元素 */
        #input-video {
            position: absolute; bottom: 0; left: 0; width: 80px; height: 100px; 
            z-index: 999; opacity: 0.5; object-fit: cover; border: 1px solid white;
        }
        
        /* 启动按钮 */
        #btn-start {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; font-size: 20px; z-index: 2000;
            background: #fff; border: none; border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="status-box">
        <div>System: Waiting for user...</div>
        <div id="hand-status">HAND: ---</div>
        <div id="fps-status">Logic: Stopped</div>
    </div>

    <button id="btn-start" onclick="startSystem()">⚡ 强制启动 (CPU模式)</button>

    <!-- 视频源 -->
    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    
    <!-- 3D 容器 -->
    <div id="canvas-container"></div>

    <!-- 依赖 -->
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- 简单的3D圣诞树 (确保视觉反馈) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 40);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const group = new THREE.Group();
        scene.add(group);

        // 简单的绿色粒子树
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<1000; i++) {
            const rRatio = i/1000;
            const y = rRatio * 30 - 15;
            const r = (1-rRatio) * 10;
            const a = i * 0.2;
            pos.push(Math.cos(a)*r, y, Math.sin(a)*r);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({color: 0x00ff00, size: 0.5});
        const tree = new THREE.Points(geo, mat);
        group.add(tree);

        // 状态变量
        let targetScale = 1;
        let rotationSpeed = 0.005;

        function animate() {
            requestAnimationFrame(animate);
            group.rotation.y += rotationSpeed;
            
            // 简单的交互反馈：缩放
            const s = group.scale.x;
            group.scale.set(
                s + (targetScale - s) * 0.1,
                s + (targetScale - s) * 0.1,
                s + (targetScale - s) * 0.1
            );
            renderer.render(scene, camera);
        }
        animate();


        // --- 核心修复逻辑 ---
        
        const video = document.getElementById('input-video');
        const statusBox = document.querySelector('#status-box div:first-child');
        const handStatus = document.getElementById('hand-status');
        const fpsStatus = document.getElementById('fps-status');

        // 1. 创建一个小尺寸的 Canvas，专门喂给 AI
        // 强制 256x256，这是 MobileNet 等模型的标准输入尺寸
        const inputCanvas = document.createElement('canvas');
        inputCanvas.width = 256;
        inputCanvas.height = 256;
        const inputCtx = inputCanvas.getContext('2d', { willReadFrequently: true }); // 关键优化

        window.startSystem = async function() {
            document.getElementById('btn-start').style.display = 'none';
            statusBox.innerText = "Step 1: Init Camera...";

            try {
                // 1. 启动摄像头
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();

                statusBox.innerText = "Step 2: Load AI (Wait)...";

                // 2. 初始化 MediaPipe
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // 强制 Lite 模型，减少 GPU 依赖
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);
                
                statusBox.innerText = "Step 3: Warming up...";
                await hands.initialize();
                
                statusBox.innerText = "System Active [CPU MODE]";
                statusBox.classList.add('ok');

                // 3. 启动低频循环 (避免死锁)
                startLowFreqLoop(hands);

            } catch (e) {
                statusBox.innerText = "Error: " + e.message;
                statusBox.classList.add('err');
                alert("Fail: " + e.message);
            }
        };

        function onResults(results) {
            if (results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                handStatus.innerText = `HAND DETECTED! X: ${lm[9].x.toFixed(2)}`;
                handStatus.style.color = '#0f0';
                handStatus.style.fontWeight = 'bold';

                // 简单的交互：
                // 如果手在屏幕左边，树变大；右边，树变小
                if (lm[9].x > 0.5) targetScale = 1.5; 
                else targetScale = 0.5;

                // 旋转速度随手张开程度变化
                rotationSpeed = 0.05;

            } else {
                handStatus.innerText = "Scanning...";
                handStatus.style.color = '#fff';
                targetScale = 1;
                rotationSpeed = 0.005;
            }
        }

        // --- 强制低频采集循环 ---
        function startLowFreqLoop(hands) {
            let lastTime = 0;
            const INTERVAL = 200; // 200ms = 5 FPS。非常慢，但绝对稳定。

            function loop(timestamp) {
                if (timestamp - lastTime > INTERVAL) {
                    lastTime = timestamp;
                    
                    if (video.readyState >= 2) {
                        fpsStatus.innerText = `Ping: ${Math.round(timestamp)}`;
                        
                        // A. 绘制到 256x256 画布 (强制缩放)
                        inputCtx.drawImage(video, 0, 0, 256, 256);
                        
                        // B. 获取像素数据 (这一步会强制 CPU 同步，绕过 GPU 死锁)
                        // 虽然性能低，但兼容性最强
                        const imageData = inputCtx.getImageData(0, 0, 256, 256);

                        // C. 发送给 AI
                        hands.send({image: inputCanvas}).catch(e => console.error(e));
                    }
                }
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

    </script>
</body>
</html>