<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree Ultimate Fix</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background: #000;
            font-family: sans-serif; touch-action: none;
        }

        /* 3D ç”»å¸ƒ */
        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        /* å…³é”®ï¼šè§†é¢‘å…ƒç´ å¿…é¡»å­˜åœ¨ä¸”æœ‰å°ºå¯¸ï¼Œä½†éšè—åœ¨åé¢ */
        /* ä¸è¦ç”¨ display:none æˆ– opacity:0ï¼Œæœ‰äº›æµè§ˆå™¨ä¼šåœæ­¢æ¸²æŸ“ */
        #input-video {
            position: absolute; top: 0; left: 0;
            width: 1px; height: 1px; /* æå° */
            z-index: -10;
            pointer-events: none;
        }

        /* è°ƒè¯•è§†å›¾ï¼šå³ä¸Šè§’å°çª—å£ï¼Œç”¨äºç¡®è®¤æ˜¯å¦è¯†åˆ«åˆ°éª¨æ¶ */
        #debug-canvas {
            position: absolute; bottom: 10px; right: 10px;
            width: 100px; height: 133px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 100;
            border-radius: 8px;
            transform: scaleX(-1); /* é•œåƒ */
        }

        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; left: 0; right: 0;
            text-align: center; z-index: 20; pointer-events: none;
        }

        .status-pill {
            display: inline-block;
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(255, 215, 0, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        /* æ•°æ®è°ƒè¯•é¢æ¿ (å·¦ä¸Šè§’) - å¦‚æœè¿˜æ˜¯ä¸è¡Œï¼Œçœ‹è¿™é‡Œçš„æ•°å­— */
        #data-debug {
            position: absolute; top: 10px; left: 10px;
            font-size: 10px; color: #0f0; background: rgba(0,0,0,0.7);
            padding: 5px; z-index: 200; pointer-events: none;
            text-align: left; font-family: monospace;
        }

        /* å¯åŠ¨æŒ‰é’® */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        button {
            background: #C41E3A; color: white; border: none;
            padding: 15px 40px; border-radius: 50px; font-size: 18px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <!-- è°ƒè¯•æ•°æ®æ˜¾ç¤º -->
    <div id="data-debug">
        CAM: Init...<br>
        HAND: No<br>
        PINCH: 0.00
    </div>

    <!-- å¯åŠ¨å±‚ -->
    <div id="overlay">
        <h2 style="color:#FFD700">ğŸ„ 3D åœ£è¯æ ‘ - æœ€ç»ˆä¿®å¤ç‰ˆ</h2>
        <p style="color:#aaa; font-size:12px; max-width:80%; text-align:center;">
            é’ˆå¯¹å°ç±³15åŠiPhone SEä¼˜åŒ–<br>
            è¯·å…è®¸æ‘„åƒå¤´æƒé™
        </p>
        <button id="btn-start">ç‚¹å‡»å¼€å§‹</button>
    </div>

    <!-- UI -->
    <div id="ui-panel">
        <div class="status-pill" id="status-text">ç­‰å¾…æ‰‹åŠ¿...</div>
    </div>

    <!-- æ ¸å¿ƒå…ƒç´  -->
    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="debug-canvas"></canvas>
    <div id="canvas-container"></div>

    <!-- è„šæœ¬ -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€çŠ¶æ€ ---
        const STATE = {
            target: 'tree',
            rotX: 0,
            hasHand: false
        };

        const DEBUG = {
            camRes: '0x0',
            pinchDist: 0
        };

        const debugEl = document.getElementById('data-debug');
        const statusEl = document.getElementById('status-text');

        // --- 1. Three.js åœºæ™¯æ„å»º ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.03);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPIé˜²è¿‡çƒ­
        container.appendChild(renderer.domElement);

        // è¾‰å…‰
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = 1.2; bloom.radius = 0.5; bloom.threshold = 0.2;
        composer.addPass(bloom);

        // èµ„æº
        const group = new THREE.Group();
        scene.add(group);

        // ç¯å…‰
        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        const light = new THREE.PointLight(0xFFD700, 2, 50);
        light.position.set(0, 20, 10);
        scene.add(light);

        // ç²’å­ç³»ç»Ÿ
        const pCount = 1000;
        const pGeo = new THREE.BufferGeometry();
        const pPos = [], pCol = [], pSizes = [];
        const tTree = [], tScatter = [];
        const colors = [new THREE.Color(0x2F5A46), new THREE.Color(0xFFD700), new THREE.Color(0xC41E3A)];

        for(let i=0; i<pCount; i++) {
            // Tree
            const rRatio = i/pCount; 
            const y = rRatio * 30 - 15;
            const r = (1 - rRatio) * 12 + Math.random();
            const angle = i * 0.2;
            const x = Math.cos(angle*8)*r; 
            const z = Math.sin(angle*8)*r;
            tTree.push(x, y, z);
            pPos.push(x, y, z);

            // Scatter
            const sr = 30 + Math.random()*10;
            const theta = Math.random()*Math.PI*2;
            const phi = Math.random()*Math.PI;
            tScatter.push(sr*Math.sin(phi)*Math.cos(theta), sr*Math.sin(phi)*Math.sin(theta), sr*Math.cos(phi));

            const c = colors[i%3];
            pCol.push(c.r, c.g, c.b);
            pSizes.push(Math.random()+0.5);
        }
        pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
        pGeo.setAttribute('color', new THREE.Float32BufferAttribute(pCol, 3));
        pGeo.setAttribute('size', new THREE.Float32BufferAttribute(pSizes, 1));
        
        // çº¹ç†
        const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
        const ctxT = cvs.getContext('2d');
        const grd = ctxT.createRadialGradient(16,16,0,16,16,16);
        grd.addColorStop(0,'rgba(255,255,255,1)'); grd.addColorStop(1,'rgba(0,0,0,0)');
        ctxT.fillStyle=grd; ctxT.fillRect(0,0,32,32);
        const tex = new THREE.CanvasTexture(cvs);

        const pMat = new THREE.PointsMaterial({
            size: 0.8, vertexColors: true, map: tex, 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
        });
        const particles = new THREE.Points(pGeo, pMat);
        group.add(particles);

        // ç…§ç‰‡ placeholders
        const photos = [];
        const planeG = new THREE.PlaneGeometry(3, 4);
        for(let i=0; i<20; i++) {
            const m = new THREE.Mesh(planeG, new THREE.MeshBasicMaterial({color: i%2?0xC41E3A:0x2F5A46, side:2}));
            const y = (i/20)*30 - 15;
            const r = (1-i/20)*12 + 2;
            m.position.set(Math.cos(i)*r, y, Math.sin(i)*r);
            m.userData = { 
                tree: m.position.clone(), 
                scatter: new THREE.Vector3((Math.random()-.5)*50, (Math.random()-.5)*50, (Math.random()-.5)*50),
                zoom: new THREE.Vector3((Math.random()-.5)*5, (Math.random()-.5)*5, 30 + Math.random()*5)
            };
            m.lookAt(0,y,0); m.rotateY(Math.PI);
            photos.push(m);
            group.add(m);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ•°æ®æ›´æ–°
            debugEl.innerHTML = `CAM: ${DEBUG.camRes}<br>HAND: ${STATE.hasHand?'YES':'NO'}<br>PINCH: ${DEBUG.pinchDist.toFixed(3)}`;

            // ç²’å­æ’å€¼
            const pos = particles.geometry.attributes.position.array;
            const target = STATE.target === 'tree' ? tTree : tScatter;
            for(let i=0; i<pCount; i++) {
                const k = i*3;
                pos[k] += (target[k]-pos[k])*0.1;
                pos[k+1] += (target[k+1]-pos[k+1])*0.1;
                pos[k+2] += (target[k+2]-pos[k+2])*0.1;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // ç…§ç‰‡æ’å€¼
            photos.forEach(p => {
                let t = p.userData.tree;
                if(STATE.target==='scatter') t = p.userData.scatter;
                if(STATE.target==='zoom') t = p.userData.zoom;
                p.position.lerp(t, 0.1);
                if(STATE.target==='zoom') p.lookAt(camera.position);
                else { p.lookAt(0, p.position.y, 0); p.rotateY(Math.PI); }
            });

            // æ—‹è½¬
            group.rotation.y += (STATE.rotX - group.rotation.y) * 0.1;
            if(!STATE.hasHand) group.rotation.y += 0.005;

            composer.render();
        }
        animate();
        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        };

        // --- 2. è§†è§‰ç®—æ³•éƒ¨åˆ† (åŸç”Ÿé‡å†™) ---
        const video = document.getElementById('input-video');
        const dbgCanvas = document.getElementById('debug-canvas');
        const dbgCtx = dbgCanvas.getContext('2d');

        // åˆå§‹åŒ– Hands
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // æ€§èƒ½å¹³è¡¡
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // ç»“æœå¤„ç†
        hands.onResults(results => {
            // ç»˜åˆ¶è°ƒè¯•å›¾
            dbgCanvas.width = video.videoWidth || 100;
            dbgCanvas.height = video.videoHeight || 133;
            dbgCtx.save();
            dbgCtx.clearRect(0, 0, dbgCanvas.width, dbgCanvas.height);
            dbgCtx.drawImage(results.image, 0, 0, dbgCanvas.width, dbgCanvas.height);
            
            if (results.multiHandLandmarks.length > 0) {
                STATE.hasHand = true;
                const lm = results.multiHandLandmarks[0];
                drawConnectors(dbgCtx, lm, HAND_CONNECTIONS, {color: '#0f0', lineWidth: 2});
                
                // ç®—æ³•é€»è¾‘
                // 1. æ—‹è½¬ (Xè½´æ˜ å°„)
                // æ‰‹æœºä¸Šå‰ç½®æ‘„åƒå¤´é€šå¸¸æ˜¯é•œåƒçš„ï¼Œä½† MediaPipe ç»™å‡ºçš„åæ ‡æ˜¯è§„èŒƒåŒ–çš„
                // å¦‚æœè§‰å¾—åäº†ï¼ŒæŠŠ (lm[9].x - 0.5) æ”¹æˆ (0.5 - lm[9].x)
                STATE.rotX = (0.5 - lm[9].x) * 5; 

                // 2. æåˆ (æ‹‡æŒ‡4 - é£ŸæŒ‡8)
                const dPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                DEBUG.pinchDist = dPinch;

                // 3. å±•å¼€ (ç»Ÿè®¡æŒ‡å°–åˆ°æ‰‹è…•è·ç¦» vs å…³èŠ‚åˆ°æ‰‹è…•è·ç¦»)
                const wrist = lm[0];
                let openCount = 0;
                [8,12,16,20].forEach((tip, i) => {
                    const pip = [6,10,14,18][i];
                    if (Math.hypot(lm[tip].x-wrist.x, lm[tip].y-wrist.y) > 
                        Math.hypot(lm[pip].x-wrist.x, lm[pip].y-wrist.y)) openCount++;
                });

                // çŠ¶æ€æœº - é˜ˆå€¼è°ƒæ•´
                // iPhone SE æåˆä¿®å¤ï¼šé˜ˆå€¼ä» 0.04 è°ƒå¤§åˆ° 0.08
                if (dPinch < 0.08) { 
                    STATE.target = 'zoom';
                    statusEl.innerText = "ğŸ” ç…§ç‰‡æ¨¡å¼";
                    statusEl.style.color = "#fff";
                } else if (openCount >= 4) {
                    STATE.target = 'scatter';
                    statusEl.innerText = "âœ¨ çˆ†ç‚¸æ•£å¼€";
                    statusEl.style.color = "#C41E3A";
                } else if (openCount <= 1) {
                    STATE.target = 'tree';
                    statusEl.innerText = "ğŸ„ åœ£è¯æ ‘";
                    statusEl.style.color = "#FFD700";
                }
            } else {
                STATE.hasHand = false;
                statusEl.innerText = "è¯·å°†æ‰‹æ”¾å…¥ç”»é¢";
                statusEl.style.color = "#aaa";
            }
            dbgCtx.restore();
        });

        // --- 3. åŸç”Ÿæ‘„åƒå¤´å¯åŠ¨ (è§£å†³å°ç±³é—®é¢˜) ---
        async function startCamera() {
            try {
                // å…³é”®ï¼šä¸è®¾ç½®å…·ä½“çš„ width/heightï¼Œåªè¯·æ±‚ 'user' (å‰ç½®)
                // è®©æµè§ˆå™¨å’Œç³»ç»Ÿåå•†æœ€ä½³åˆ†è¾¨ç‡ï¼Œé˜²æ­¢è¢«ç³»ç»Ÿæ‹’ç»
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        // å¦‚æœå¿…é¡»åŠ é™åˆ¶ï¼ŒåªåŠ  ideal
                        width: { ideal: 640 }, 
                        height: { ideal: 480 }
                    },
                    audio: false
                });

                video.srcObject = stream;
                // å¿…é¡»åœ¨ loadedmetadata åæ‰èƒ½è·å–çœŸå®åˆ†è¾¨ç‡
                video.onloadedmetadata = () => {
                    video.play();
                    DEBUG.camRes = `${video.videoWidth}x${video.videoHeight}`;
                    processVideo(); // å¼€å§‹è¯†åˆ«å¾ªç¯
                    document.getElementById('overlay').style.display = 'none';
                };
            } catch (err) {
                console.error(err);
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š\n" + err.name + "\nè¯·ç¡®ä¿ä½¿ç”¨HTTPSä¸”å…è®¸æƒé™");
            }
        }

        // æ‰‹åŠ¨å¤„ç†å¾ªç¯ (æ›¿ä»£ camera_utils)
        let lastVideoTime = -1;
        async function processVideo() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                // åªæœ‰å½“è§†é¢‘çœŸçš„åœ¨æ’­æ”¾ä¸”æœ‰æ•°æ®æ—¶æ‰å‘é€
                if(video.videoWidth > 0) {
                    await hands.send({image: video});
                }
            }
            requestAnimationFrame(processVideo);
        }

        document.getElementById('btn-start').onclick = startCamera;

    </script>
</body>
</html>