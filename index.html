<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree: Stable Pro</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; font-family: -apple-system, sans-serif; }
        
        /* 3D ä¸»åœºæ™¯ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* éšè—çš„æºè§†é¢‘ (ç”¨äºé‡‡é›†æ•°æ®ï¼Œä¸å¯è§) */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; opacity: 0; z-index: -10; pointer-events: none;
        }

        /* å³ä¸‹è§’ç”¨æˆ·é¢„è§ˆçª—å£ (ç”»ä¸­ç”») */
        #preview-canvas {
            position: absolute; bottom: 20px; right: 20px;
            width: 120px; height: 160px; /* ç«–å±æ¯”ä¾‹ */
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            z-index: 100;
            transform: scaleX(-1); /* é•œåƒï¼Œåƒé•œå­ä¸€æ · */
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        /* çŠ¶æ€æŒ‡ç¤ºæ¡ */
        #status-pill {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(10, 10, 10, 0.8); border: 1px solid rgba(255, 215, 0, 0.4);
            padding: 8px 24px; border-radius: 30px;
            color: #FFD700; font-size: 14px; font-weight: 600;
            z-index: 50; pointer-events: none; white-space: nowrap;
            display: flex; align-items: center; gap: 8px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #333; transition: background 0.3s; }
        .dot.active { background: #0f0; box-shadow: 0 0 8px #0f0; }

        /* å¯åŠ¨é®ç½© */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        #btn-start {
            background: linear-gradient(135deg, #C41E3A, #800000);
            color: white; border: none; padding: 18px 50px; border-radius: 50px;
            font-size: 18px; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 25px rgba(196, 30, 58, 0.6);
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <div id="status-pill">
        <div class="dot" id="status-dot"></div>
        <span id="status-text">ç­‰å¾…å¯åŠ¨...</span>
    </div>

    <div id="overlay">
        <h1 style="color:#FFD700; margin-bottom:5px;">ğŸ„ åœ£è¯æ ‘ Â· æ——èˆ°ç‰ˆ</h1>
        <p style="color:#888; font-size:12px;">é€‚é… Xiaomi 15 & iPhone</p>
        <button id="btn-start" onclick="startApp()">ç‚¹å‡»å¼€å§‹ä½“éªŒ</button>
        <p id="loading-msg" style="color:#666; font-size:12px; margin-top:15px; min-height:1.2em;"></p>
    </div>

    <!-- è§†é¢‘æµå¤„ç†é“¾ -->
    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="preview-canvas"></canvas> <!-- ç”¨æˆ·çœ‹è¿™ä¸ª -->
    
    <div id="canvas-container"></div>

    <!-- åº“æ–‡ä»¶ -->
    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- æ ¸å¿ƒå˜é‡ ---
        const STATE = { 
            target: 'tree',      // tree, scatter, zoom
            currentRotX: 0,      // å¹³æ»‘åçš„æ—‹è½¬å€¼
            targetRotX: 0,       // ç›®æ ‡æ—‹è½¬å€¼
            hasHand: false
        };

        // --- 1. Three.js è§†è§‰ç³»ç»Ÿ (å¸¦å¹³æ»‘) ---
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.03);
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.camera.position.set(0, 10, 45);

                this.renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // è¾‰å…‰
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                this.composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

                // èµ„æºç»„
                this.group = new THREE.Group();
                this.scene.add(this.group);
                
                this.initAssets();
                this.animate();
                window.addEventListener('resize', () => this.resize());
            }

            initAssets() {
                // ç¯å…‰
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.2));
                const l = new THREE.PointLight(0xFFD700, 2, 80);
                l.position.set(0, 20, 20);
                this.scene.add(l);

                // 1. ç²’å­
                const pGeo = new THREE.BufferGeometry();
                const count = 1500;
                const pos=[], col=[], tTree=[], tScatter=[];
                const colors = [0x2F5A46, 0xFFD700, 0xC41E3A, 0xFFFFFF].map(c => new THREE.Color(c));

                for(let i=0; i<count; i++) {
                    // Tree
                    const rRatio = i/count;
                    const y = rRatio * 35 - 17.5;
                    const r = (1-rRatio) * 14 + Math.random();
                    const a = i * 0.18;
                    tTree.push(Math.cos(a*10)*r, y, Math.sin(a*10)*r);
                    
                    // Scatter
                    const sr = 40 + Math.random()*20;
                    const phi = Math.acos(2*Math.random()-1), theta = Math.random()*Math.PI*2;
                    tScatter.push(sr*Math.sin(phi)*Math.cos(theta), sr*Math.sin(phi)*Math.sin(theta), sr*Math.cos(phi));
                    
                    pos.push(tTree[i*3], tTree[i*3+1], tTree[i*3+2]);
                    const c = colors[i%4];
                    col.push(c.r, c.g, c.b);
                }
                pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                pGeo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
                pGeo.userData = { tree: tTree, scatter: tScatter };

                // çº¹ç†
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);

                const pMat = new THREE.PointsMaterial({
                    size: 0.7, vertexColors: true, map: new THREE.CanvasTexture(cvs),
                    blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
                });
                this.particles = new THREE.Points(pGeo, pMat);
                this.group.add(this.particles);

                // 2. ç…§ç‰‡æ¿
                this.photos = [];
                const plane = new THREE.PlaneGeometry(3.5, 4.5);
                for(let i=0; i<24; i++) {
                    const m = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({color:i%2?0xC41E3A:0x2F5A46, side:2}));
                    const y = (i/24)*35 - 17.5;
                    const r = (1-i/24)*14 + 2.5;
                    const a = i*0.6;
                    
                    m.userData = {
                        tree: new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r),
                        zoom: new THREE.Vector3((Math.random()-.5)*8, (Math.random()-.5)*8, 35+Math.random()*5),
                        scatter: new THREE.Vector3((Math.random()-.5)*80, (Math.random()-.5)*80, (Math.random()-.5)*80)
                    };
                    m.position.copy(m.userData.tree);
                    m.lookAt(0,y,0); m.rotateY(Math.PI);
                    this.photos.push(m);
                    this.group.add(m);
                }
            }

            resize() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // 1. æ—‹è½¬å¹³æ»‘å¤„ç† (Lerp)
                // åªæœ‰å½“æœ‰æ‰‹æ—¶ï¼Œæ‰å»æ¥è¿‘ç›®æ ‡å€¼ï¼›æ²¡æ‰‹æ—¶è‡ªåŠ¨æ—‹è½¬
                if (STATE.hasHand) {
                    STATE.currentRotX += (STATE.targetRotX - STATE.currentRotX) * 0.1; // 0.1 ç³»æ•°è¶Šå°è¶Šå¹³æ»‘
                } else {
                    STATE.currentRotX += 0.003; // è‡ªåŠ¨æ—‹è½¬
                }
                this.group.rotation.y = STATE.currentRotX;

                // 2. çŠ¶æ€æ’å€¼
                const pos = this.particles.geometry.attributes.position.array;
                const targetP = STATE.target === 'tree' ? this.particles.geometry.userData.tree : this.particles.geometry.userData.scatter;
                
                // ç²’å­æ›´æ–°
                for(let i=0; i<pos.length; i++) {
                    pos[i] += (targetP[i] - pos[i]) * 0.08;
                }
                // åœ£è¯æ ‘çŠ¶æ€ä¸‹åŠ ä¸€ç‚¹é—ªçƒæŠ–åŠ¨
                if(STATE.target === 'tree') {
                    for(let i=1; i<pos.length; i+=3) pos[i] += Math.sin(Date.now()*0.003 + i)*0.02;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                // ç…§ç‰‡æ›´æ–°
                this.photos.forEach(p => {
                    let t = p.userData.tree;
                    if(STATE.target==='scatter') t = p.userData.scatter;
                    if(STATE.target==='zoom') t = p.userData.zoom;
                    
                    p.position.lerp(t, 0.08);
                    
                    if(STATE.target==='zoom') {
                        p.lookAt(this.camera.position);
                    } else {
                        // å¹³æ»‘æ¢å¤æœå‘
                        const tempQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, Math.atan2(p.position.x, p.position.z)+Math.PI, 0));
                        p.quaternion.slerp(tempQ, 0.1);
                    }
                });

                this.composer.render();
            }
        }

        // --- 2. AI è§†è§‰å¤„ç† ---
        const video = document.getElementById('input-video');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const loadMsg = document.getElementById('loading-msg');
        
        // ä¸­é—´å±‚ Canvas (æ•°æ®æ¸…æ´—)
        const processCanvas = document.createElement('canvas');
        const processCtx = processCanvas.getContext('2d', { alpha: false });

        window.startApp = async function() {
            const btn = document.getElementById('btn-start');
            btn.disabled = true; btn.innerText = "å¯åŠ¨ä¸­...";
            
            // 1. å¯åŠ¨åœºæ™¯
            new SceneManager();

            try {
                // 2. å¯åŠ¨æ‘„åƒå¤´
                loadMsg.innerText = "æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...";
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                await new Promise(r => video.onloadedmetadata = r);
                video.play();

                // 3. åŠ è½½ MediaPipe (æ¢å¤ä½¿ç”¨é«˜ç²¾åº¦æ¨¡å‹)
                loadMsg.innerText = "æ­£åœ¨åŠ è½½ AI æ¨¡å‹ (è¯·ä¿æŒç½‘ç»œç•…é€š)...";
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // æ¢å¤ä¸º 1 (Full Model) ä»¥æ¶ˆé™¤é¬¼æ‰‹
                    minDetectionConfidence: 0.7, // æé«˜é˜ˆå€¼ï¼Œ70% ç¡®ä¿¡æ‰ç®—æ‰‹
                    minTrackingConfidence: 0.6
                });
                
                hands.onResults(onResults);
                
                loadMsg.innerText = "æ­£åœ¨åˆå§‹åŒ–å¼•æ“...";
                await hands.initialize(); // å¼ºåˆ¶é¢„çƒ­
                
                // éšè—é®ç½©
                document.getElementById('overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('overlay').style.display='none', 500);
                
                // å¼€å¯å¾ªç¯
                processLoop(hands);

            } catch(e) {
                console.error(e);
                alert("å¯åŠ¨å‡ºé”™: " + e.message);
                btn.disabled = false; btn.innerText = "é‡è¯•";
            }
        };

        function onResults(results) {
            // 1. ç»˜åˆ¶ç”¨æˆ·é¢„è§ˆ (å³ä¸‹è§’)
            // ç¡®ä¿ç”»å¸ƒå°ºå¯¸åŒ¹é…
            if(previewCanvas.width !== video.videoWidth) {
                previewCanvas.width = video.videoWidth;
                previewCanvas.height = video.videoHeight;
            }
            
            previewCtx.clearRect(0,0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            // 2. é€»è¾‘å¤„ç†
            if (results.multiHandLandmarks.length > 0) {
                STATE.hasHand = true;
                const lm = results.multiHandLandmarks[0];

                // åœ¨é¢„è§ˆå›¾ä¸Šç”»éª¨æ¶ (è¯æ˜ AI åœ¨å·¥ä½œ)
                drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(previewCtx, lm, {color: '#FF0000', lineWidth: 1});

                // æ›´æ–°çŠ¶æ€UI
                statusDot.classList.add('active');
                
                // --- æ ¸å¿ƒç®—æ³• ---
                
                // A. æ—‹è½¬ (é•œåƒç¿»è½¬ä¿®æ­£ + çµæ•åº¦è°ƒæ•´)
                // lm[9] æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œæ¯”è¾ƒç¨³ã€‚æ‰‹æœºé•œåƒé€šå¸¸ X è½´æ˜¯åçš„ã€‚
                const rawX = lm[9].x;
                STATE.targetRotX = (0.5 - rawX) * 5; // ç›®æ ‡å€¼ï¼Œç”± SceneManager è¿›è¡Œ Lerp å¹³æ»‘

                // B. æåˆ (æ‹‡æŒ‡4 - é£ŸæŒ‡8)
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                // C. å±•å¼€æ£€æµ‹
                const wrist = lm[0];
                let openFingers = 0;
                [8,12,16,20].forEach((tip, i) => {
                    const pip = [6,10,14,18][i];
                    // å¿…é¡»æ˜æ˜¾ä¼¸ç›´æ‰ç®—
                    if(Math.hypot(lm[tip].x-wrist.x, lm[tip].y-wrist.y) > Math.hypot(lm[pip].x-wrist.x, lm[pip].y-wrist.y) * 1.2) 
                        openFingers++;
                });

                // D. çŠ¶æ€æœº (å¸¦å»æŠ–åŠ¨é€»è¾‘ä¼šæ›´å¤æ‚ï¼Œè¿™é‡Œç®€åŒ–ä½†ä¾é é«˜ç½®ä¿¡åº¦)
                if (pinchDist < 0.06) { // ç¨å¾®ä¸¥æ ¼ä¸€ç‚¹
                    STATE.target = 'zoom';
                    statusText.innerText = "ğŸ” ç…§ç‰‡æ¨¡å¼";
                    statusText.style.color = "#fff";
                } else if (openFingers >= 4) {
                    STATE.target = 'scatter';
                    statusText.innerText = "âœ¨ æ•£å¼€æ¨¡å¼";
                    statusText.style.color = "#C41E3A";
                } else {
                    STATE.target = 'tree';
                    statusText.innerText = "ğŸ„ åœ£è¯æ ‘";
                    statusText.style.color = "#FFD700";
                }

            } else {
                STATE.hasHand = false;
                statusDot.classList.remove('active');
                statusText.innerText = "å¯»æ‰¾æ‰‹åŠ¿...";
                statusText.style.color = "#888";
            }
        }

        // å¾ªç¯å¼•æ“
        async function processLoop(hands) {
            // é™åˆ¶å¤„ç†å¸§ç‡ï¼Œç»™æ¸²æŸ“ç•™ CPU
            if (video.readyState >= 2) {
                // è®¾ç½®ä¸­é—´å±‚å°ºå¯¸ (é™é‡‡æ ·åˆ° 640å®½ï¼Œä¿è¯é€Ÿåº¦å’Œç²¾åº¦çš„å¹³è¡¡)
                const targetWidth = 640;
                const scale = targetWidth / video.videoWidth;
                const targetHeight = video.videoHeight * scale;

                if(processCanvas.width !== targetWidth) {
                    processCanvas.width = targetWidth;
                    processCanvas.height = targetHeight;
                }
                
                // 1. æŠ“å–è§†é¢‘å¸§
                processCtx.drawImage(video, 0, 0, targetWidth, targetHeight);
                
                // 2. å‘é€ç»™ AI
                await hands.send({image: processCanvas});
            }
            // ä½¿ç”¨ setTimeout ç¨å¾®æ§åˆ¶ä¸€ä¸‹é¢‘ç‡ï¼Œçº¦ 30fps
            setTimeout(() => requestAnimationFrame(() => processLoop(hands)), 30);
        }

    </script>
</body>
</html>