<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumina Memories - 3D äº¤äº’åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }
        
        .loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
            text-shadow: 0 0 10px rgba(255,215,0, 0.8);
            transition: opacity 0.5s;
        }

        .hud {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .controls-hint {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .controls-hint span {
            display: inline-block; margin: 0 15px;
            padding: 5px 10px; border: 1px solid rgba(255,255,255,0.3);
            border-radius: 20px; background: rgba(0,0,0,0.4);
        }
    </style>
    
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- éšè—çš„è§†é¢‘è¾“å…¥æº -->
    <video id="video-input"></video>

    <div id="ui-layer">
        <div class="hud">LUMINA MEMORIES // v1.0</div>
        <div id="loading-text" class="loading">
            æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ ¸å¿ƒ...<br>
            <span style="font-size:14px; opacity:0.7">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯äº¤äº’ä½“éªŒ</span>
        </div>
        <div class="controls-hint" id="hints" style="opacity: 0;">
            <span>ğŸ– å¼ æ‰‹: æ•£å¼€è®°å¿†</span>
            <span>âœŠ æ¡æ‹³: èšåˆåœ£è¯æ ‘</span>
            <span>â†” ç§»åŠ¨: æ—‹è½¬è§†è§’</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. åŸºç¡€åœºæ™¯è®¾ç½®
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02); // æ·±è“è¿·é›¾

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x050510);
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffd700, 2, 50);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // ==========================================
        // 2. ç”Ÿæˆç´ æ (ç¨‹åºåŒ–ç”Ÿæˆï¼Œä¸ä¾èµ–å¤–éƒ¨å›¾ç‰‡)
        // ==========================================
        
        // ç”Ÿæˆâ€œæ‹ç«‹å¾—â€çº¹ç†
        function createPolaroidTexture(seed) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // æ‹ç«‹å¾—ç™½è¾¹
            ctx.fillStyle = '#fdfdfd';
            ctx.fillRect(0, 0, 256, 300);
            
            // å†…éƒ¨ç…§ç‰‡åŒºåŸŸ (ç”ŸæˆæŠ½è±¡è‰ºæœ¯)
            ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 50%)`;
            ctx.fillRect(20, 20, 216, 216);
            
            // æ·»åŠ ä¸€äº›éšæœºå›¾æ¡ˆ
            for(let i=0; i<5; i++) {
                ctx.fillStyle = `rgba(255,255,255, ${Math.random() * 0.5})`;
                ctx.beginPath();
                ctx.arc(20 + Math.random()*216, 20 + Math.random()*216, Math.random()*50, 0, Math.PI*2);
                ctx.fill();
            }

            // é˜´å½±/å¤å¤æ»¤é•œå±‚
            const grd = ctx.createLinearGradient(0, 0, 256, 300);
            grd.addColorStop(0, "rgba(255,240,200,0.2)");
            grd.addColorStop(1, "rgba(0,0,0,0.1)");
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,256,300);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // ==========================================
        // 3. æ„å»º 3D å¯¹è±¡ (æ ‘ ä¸ ç²’å­)
        // ==========================================
        
        const memories = []; // å­˜å‚¨ç…§ç‰‡å¯¹è±¡
        const particleCount = 2000;
        const memoryCount = 80;
        
        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // A. æ„å»ºç…§ç‰‡ (Memories)
        const photoGeometry = new THREE.PlaneGeometry(1.2, 1.4);
        
        for (let i = 0; i < memoryCount; i++) {
            const material = new THREE.MeshPhongMaterial({
                map: createPolaroidTexture(i),
                side: THREE.DoubleSide,
                shininess: 100,
                specular: 0x222222
            });
            
            const mesh = new THREE.Mesh(photoGeometry, material);
            
            // --- æ•°å­¦è®¡ç®—ï¼šè´¹é©¬èºæ—‹ (Fermat's Spiral) ---
            // 1. æ ‘å½¢æ€ (Tree Position)
            const y = -8 + (i / memoryCount) * 16; // é«˜åº¦ä» -8 åˆ° 8
            const radius = 6 * (1 - (i / memoryCount)); // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const theta = i * 2.4; // é»„é‡‘è§’è¿‘ä¼¼å€¼
            
            const treePos = new THREE.Vector3(
                Math.cos(theta) * radius,
                y,
                Math.sin(theta) * radius
            );
            
            // 2. æ•£å¼€å½¢æ€ (Galaxy Position) - çƒå½¢éšæœºåˆ†å¸ƒ
            const phi = Math.acos(-1 + (2 * i) / memoryCount);
            const galaxyRadius = 12 + Math.random() * 5;
            const galaxyPos = new THREE.Vector3(
                galaxyRadius * Math.sin(phi) * Math.cos(theta),
                galaxyRadius * Math.cos(phi),
                galaxyRadius * Math.sin(phi) * Math.sin(theta)
            );

            // å­˜å‚¨æ•°æ®ä¾›åŠ¨ç”»ä½¿ç”¨
            mesh.userData = {
                treePos: treePos,
                galaxyPos: galaxyPos,
                rotationOffset: Math.random() * Math.PI,
                randomSpeed: 0.5 + Math.random()
            };

            // åˆå§‹ä½ç½®
            mesh.position.copy(treePos);
            mesh.lookAt(0, y, 0); // æœå‘ä¸­å¿ƒ
            
            mainGroup.add(mesh);
            memories.push(mesh);
        }

        // B. æ„å»ºå…‰ä¹‹å°˜ (Particles)
        const particlesGeometry = new THREE.BufferGeometry();
        const pPositions = [];
        const pTreeTargets = [];
        const pGalaxyTargets = [];
        
        for (let i = 0; i < particleCount; i++) {
            // æ ‘å½¢æ€ç²’å­ï¼šç´§è´´æ ‘è¡¨é¢èºæ—‹
            const y = -8 + Math.random() * 16;
            const radius = 6.5 * (1 - ((y+8)/16)) + Math.random() * 0.5;
            const theta = Math.random() * Math.PI * 2 * 20; // æ›´å¤šåœˆ
            
            const tx = Math.cos(theta) * radius;
            const tz = Math.sin(theta) * radius;
            
            pPositions.push(tx, y, tz);
            pTreeTargets.push(tx, y, tz);
            
            // æ•£å¼€å½¢æ€ç²’å­ï¼šå¼¥æ¼«æ•´ä¸ªç©ºé—´
            const gr = 10 + Math.random() * 15;
            const gTheta = Math.random() * Math.PI * 2;
            const gPhi = Math.acos(2 * Math.random() - 1);
            
            pGalaxyTargets.push(
                gr * Math.sin(gPhi) * Math.cos(gTheta),
                gr * Math.cos(gPhi),
                gr * Math.sin(gPhi) * Math.sin(gTheta)
            );
        }

        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
        particlesGeometry.setAttribute('treeTarget', new THREE.Float32BufferAttribute(pTreeTargets, 3));
        particlesGeometry.setAttribute('galaxyTarget', new THREE.Float32BufferAttribute(pGalaxyTargets, 3));

        // ç®€å•çš„å‘å…‰ç²’å­æè´¨
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xffd700,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending // å…³é”®ï¼šå åŠ å‘å…‰
        });

        const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
        mainGroup.add(particleSystem);

        // æ ‘é¡¶æ˜Ÿæ˜Ÿ
        const starGeo = new THREE.OctahedronGeometry(0.8, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        const topStar = new THREE.Mesh(starGeo, starMat);
        topStar.position.set(0, 8.5, 0);
        mainGroup.add(topStar);


        // ==========================================
        // 4. çŠ¶æ€ç®¡ç†ä¸åŠ¨ç”»å¾ªç¯
        // ==========================================
        
        const state = {
            expansion: 0, // 0 = æ ‘, 1 = æ•£å¼€
            targetExpansion: 0,
            rotationVelocity: 0.002, // è‡ªåŠ¨æ—‹è½¬é€Ÿåº¦
            targetRotationY: 0,
            isHandDetected: false
        };

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. å¹³æ»‘è¿‡æ¸¡ Expansion (Lerp)
            state.expansion += (state.targetExpansion - state.expansion) * 3.0 * delta;

            // 2. æ›´æ–°ç…§ç‰‡ä½ç½®
            memories.forEach((mesh, i) => {
                // ä½ç½®æ’å€¼
                const currentPos = new THREE.Vector3().lerpVectors(
                    mesh.userData.treePos,
                    mesh.userData.galaxyPos,
                    state.expansion
                );
                
                // æ‚¬æµ®å‘¼å¸æ•ˆæœ
                currentPos.y += Math.sin(time * mesh.userData.randomSpeed + i) * 0.05;
                
                mesh.position.copy(currentPos);
                
                // æ—‹è½¬é€»è¾‘ï¼šèšåˆæ—¶æœå‘ä¸­å¿ƒï¼Œæ•£å¼€æ—¶éšå³æ¼‚æµ®
                if (state.expansion < 0.1) {
                    mesh.lookAt(0, mesh.position.y, 0);
                    mesh.rotation.y += Math.PI; // ä¿®æ­£é¢æœå‘
                } else {
                    mesh.rotation.x += delta * 0.1;
                    mesh.rotation.y += delta * 0.1;
                }
            });

            // 3. æ›´æ–°ç²’å­ä½ç½® (ç›´æ¥æ“ä½œ BufferAttribute)
            const positions = particleSystem.geometry.attributes.position.array;
            const treeTargets = particleSystem.geometry.attributes.treeTarget.array;
            const galaxyTargets = particleSystem.geometry.attributes.galaxyTarget.array;

            for(let i=0; i<particleCount; i++) {
                const i3 = i * 3;
                // ç®€å•çš„çº¿æ€§æ’å€¼
                positions[i3] = treeTargets[i3] * (1 - state.expansion) + galaxyTargets[i3] * state.expansion;
                positions[i3+1] = treeTargets[i3+1] * (1 - state.expansion) + galaxyTargets[i3+1] * state.expansion;
                positions[i3+2] = treeTargets[i3+2] * (1 - state.expansion) + galaxyTargets[i3+2] * state.expansion;
                
                // ç²’å­é—ªçƒ
                if (Math.random() > 0.95) {
                   positions[i3+1] += (Math.random() - 0.5) * 0.1; 
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            // 4. æ•´ä½“æ—‹è½¬æ§åˆ¶
            if (state.isHandDetected) {
                // æ‰‹åŠ¿æ§åˆ¶ï¼šå¹³æ»‘æ—‹è½¬è‡³ç›®æ ‡è§’åº¦
                // ç®€å•çš„æƒ¯æ€§æ¨¡æ‹Ÿ
                mainGroup.rotation.y += (state.targetRotationY - mainGroup.rotation.y) * 2 * delta;
            } else {
                // æ— æ‰‹åŠ¿ï¼šè‡ªåŠ¨æ¼«æ¸¸æ—‹è½¬
                mainGroup.rotation.y += state.rotationVelocity;
            }

            // é¡¶éƒ¨æ˜Ÿæ˜Ÿæ—‹è½¬
            topStar.rotation.y -= delta;
            topStar.rotation.z += delta * 0.5;

            renderer.render(scene, camera);
        }

        animate();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // 5. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
        // ==========================================
        
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            // éšè— Loading
            document.getElementById('loading-text').style.opacity = 0;
            document.getElementById('hints').style.opacity = 1;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // --- äº¤äº’é€»è¾‘ A: æ—‹è½¬ (åŸºäºæ‰‹è…•åœ¨å±å¹•çš„Xåæ ‡) ---
                const wrist = landmarks[0];
                // æ˜ å°„ 0-1 åˆ° -PI åˆ° PI
                const targetRot = (wrist.x - 0.5) * -Math.PI * 2; // åå‘ä»¥ç¬¦åˆç›´è§‰
                state.targetRotationY = targetRot;

                // --- äº¤äº’é€»è¾‘ B: èšåˆ/æ•£å¼€ (åŸºäºæŒ‡å°–è·ç¦») ---
                // è®¡ç®—æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)çš„è·ç¦»
                const thumb = landmarks[4];
                const index = landmarks[8];
                const middle = landmarks[12];
                const ring = landmarks[16];
                const pinky = landmarks[20];

                // ç®€å•çš„åˆ¤æ–­ï¼šæ‰‹æŒå¼ å¼€ vs æ¡æ‹³
                // å¦‚æœæŒ‡å°–ç¦»æ‰‹è…•(0)å¾ˆè¿œ -> å¼ å¼€ã€‚å¦‚æœå¾ˆè¿‘ -> æ¡æ‹³ã€‚
                // è¿™é‡Œç”¨æ›´ç®€å•çš„ï¼šæ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»
                const pinchDist = Math.sqrt(
                    Math.pow(thumb.x - index.x, 2) + 
                    Math.pow(thumb.y - index.y, 2)
                );

                // é˜ˆå€¼åˆ¤æ–­ (è§†æ‘„åƒå¤´è·ç¦»è€Œå®šï¼Œé€šå¸¸0.1-0.2æ˜¯åˆ†ç•Œçº¿)
                // æˆ–è€…åˆ¤æ–­æ‰€æœ‰æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´ï¼ˆyåæ ‡å¯¹æ¯”ï¼‰
                
                // é€»è¾‘ï¼šå¦‚æœæ‹‡æŒ‡å’Œé£ŸæŒ‡åˆ†å¾—å¼€ -> å¼ å¼€ (Expand)
                if (pinchDist > 0.15) {
                    state.targetExpansion = 1.0;
                } else {
                    state.targetExpansion = 0.0;
                }

            } else {
                state.isHandDetected = false;
                state.targetExpansion = 0.0; // æ‰‹æ¶ˆå¤±æ—¶è‡ªåŠ¨å˜å›æ ‘
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // å¯åŠ¨æ‘„åƒå¤´
        cameraUtils.start().catch(err => {
            console.error("Camera init failed:", err);
            document.getElementById('loading-text').innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´<br>å°†ä»¥è‡ªåŠ¨æ¼”ç¤ºæ¨¡å¼è¿è¡Œ";
            // å³ä½¿æ²¡æœ‰æ‘„åƒå¤´ï¼Œ3Dåœºæ™¯ä¾ç„¶ä¼šè¿è¡Œ
        });

    </script>
</body>
</html>